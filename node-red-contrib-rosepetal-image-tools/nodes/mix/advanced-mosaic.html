<!-- ───────── nodes/mix/advanced-mosaic.html ────────────── -->

<!-- 1 ▸ Runtime registration -->
<script type="text/javascript">
  RED.nodes.registerType('advanced-mosaic',{
  
    category:'RP Image',
    color   :'#DA70D6',
    icon    :'font-awesome/fa-th-large',
  
    defaults:{
      name:{value:""},
      inputPath:{value:"payload"},   inputPathType:{value:"msg"},
      outputPath:{value:"payload"},  outputPathType:{value:"msg"},
      outputFormat:{value:"raw"},
      outputQuality:{value:90},
      pngOptimize:{value:false},
      // Debug configuration
      debugEnabled:{value:false},
      debugWidth:{value:200},
      debugWidthType:{value:"num"},
  
      canvasWidth:{value:"800"},   canvasWidthType:{value:"num"},
      canvasHeight:{value:"600"},  canvasHeightType:{value:"num"},
      backgroundColor:{value:"#000000"},
      
      imageConfigs:{value:[]}  // Array of {arrayIndex, x, y, width, height, rotation, zIndex} objects
    },
  
    inputs:1, outputs:1,
    label:function(){ return this.name || "advanced-mosaic"; },
  
    /* ---------------- oneditprepare ---------------- */
    oneditprepare:function(){
      const node = this;
  
      /* Standard I/O typedInputs */
      $("#node-input-inputPath").typedInput({
        default:'msg',types:['msg','flow','global'],
        typeField:"#node-input-inputPathType"
      });
      $("#node-input-outputPath").typedInput({
        default:'msg',types:['msg','flow','global'],
        typeField:"#node-input-outputPathType"
      });
  
      /* Canvas dimension typedInputs */
      $("#node-input-canvasWidth").typedInput({
        default:'num',
        types:['num','msg','flow','global'],
        typeField:"#node-input-canvasWidthType"
      });
      $("#node-input-canvasHeight").typedInput({
        default:'num',
        types:['num','msg','flow','global'],
        typeField:"#node-input-canvasHeightType"
      });
  

      /* Quality visibility based on output format */
      function updateQualityVisibility(){
        const format = $("#node-input-outputFormat").val();
        $("#quality-row").toggle(format === "jpg" || format === "webp");
        $("#png-optimize-row").toggle(format === "png");
      }
      $("#node-input-outputFormat").on("change", updateQualityVisibility);
      updateQualityVisibility(); // initial state

      // === Debug Display Logic ===
      const debugCheckbox = $('#node-input-debugEnabled');
      const debugWidthRow = $('#debug-width-row');
      
      // Initialize debug width TypedInput
      $("#node-input-debugWidth").typedInput({
          default: 'num',
          types: ['num', 'msg', 'flow', 'global'],
          typeField: "#node-input-debugWidthType"
      });
      
      // Function to toggle debug width visibility
      function updateDebugWidthVisibility() {
          if (debugCheckbox.is(':checked')) {
              debugWidthRow.show();
          } else {
              debugWidthRow.hide();
          }
      }
      
      // Initialize debug state on node open
      updateDebugWidthVisibility();
      
      // Handle debug checkbox changes
      debugCheckbox.on('change', function() {
          updateDebugWidthVisibility();
      });

      /* Initialize image configurations if empty */
      if (!node.imageConfigs || node.imageConfigs.length === 0) {
        node.imageConfigs = [{
          arrayIndex: 0, 
          inputWidth: 800,
          inputHeight: 600,
          x: 50, 
          y: 50, 
          width: 200, 
          height: 150, 
          rotation: 0, 
          zIndex: 0
        }];
      }

      /* Interactive Canvas Editor */
      class MosaicCanvasEditor {
        constructor(canvasElement, node) {
          this.canvas = canvasElement;
          this.ctx = this.canvas.getContext('2d');
          this.node = node;
          this.selectedIndex = -1;
          this.isDragging = false;
          this.isResizing = false;
          this.isRotating = false;
          this.resizeHandle = null; // 'nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'
          this.dragStartX = 0;
          this.dragStartY = 0;
          this.originalBounds = null;
          this.showGrid = true;
          this.snapToGrid = true;
          this.gridSize = 20;
          this.handleSize = 8;
          
          // Enhanced magnetic grid features
          this.magneticSnap = true;
          this.magneticDistance = 10; // pixels
          this.snapLines = []; // Visual feedback for snapping
          
          // Aspect ratio preservation
          this.shiftPressed = false;
          this.preserveAspectRatio = true; // Default behavior
          this.originalAspectRatio = 1.0;
          
          this.setupEventListeners();
          this.updateCanvasSize();
          this.render();
        }
        
        updateCanvasSize() {
          const width = parseInt($("#node-input-canvasWidth").val()) || 800;
          const height = parseInt($("#node-input-canvasHeight").val()) || 600;
          
          // Get available width from the canvas container (Node-RED dialog width minus padding)
          const containerWidth = $('#canvas-container').width() || 600;
          const availableWidth = Math.min(containerWidth - 20, 800); // Leave some padding
          const availableHeight = Math.min(availableWidth * 0.75, 500); // Maintain reasonable aspect ratio
          
          // Scale to fit available space while maintaining aspect ratio
          const scale = Math.min(availableWidth/width, availableHeight/height, 1);
          this.canvas.width = width * scale;
          this.canvas.height = height * scale;
          this.canvas.style.width = `${width * scale}px`;
          this.canvas.style.height = `${height * scale}px`;
          this.canvas.style.maxWidth = '100%';
          this.canvas.style.maxHeight = '500px';
          this.scale = scale;
          this.canvasWidth = width;
          this.canvasHeight = height;
        }
        
        setupEventListeners() {
          this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
          this.canvas.addEventListener('mousemove', (e) => {
            this.handleMouseMove(e);
            this.updateCursor(e);
          });
          this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
          this.canvas.addEventListener('click', (e) => this.handleClick(e));
          
          // Canvas size change listeners
          $("#node-input-canvasWidth, #node-input-canvasHeight").on('input', () => {
            this.updateCanvasSize();
            this.render();
          });
          
          // Window resize listener to adjust canvas size
          $(window).on('resize', () => {
            setTimeout(() => {
              this.updateCanvasSize();
              this.render();
            }, 100);
          });
          
          // Keyboard event listeners for shift key detection
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Shift') {
              this.shiftPressed = true;
            }
          });
          
          document.addEventListener('keyup', (e) => {
            if (e.key === 'Shift') {
              this.shiftPressed = false;
            }
          });
        }
        
        getMousePos(e) {
          const rect = this.canvas.getBoundingClientRect();
          return {
            x: (e.clientX - rect.left) / this.scale,
            y: (e.clientY - rect.top) / this.scale
          };
        }
        
        snapToGridPos(x, y) {
          if (!this.snapToGrid) return {x, y};
          return {
            x: Math.round(x / this.gridSize) * this.gridSize,
            y: Math.round(y / this.gridSize) * this.gridSize
          };
        }
        
        // Enhanced magnetic snapping to edges and canvas boundaries
        magneticSnapPosition(x, y, width, height, excludeIndex = -1) {
          if (!this.magneticSnap) return { x, y, snapLines: [] };
          
          let snappedX = x;
          let snappedY = y;
          const snapLines = [];
          const dist = this.magneticDistance;
          
          // Canvas boundary snapping
          // Left edge
          if (Math.abs(x) < dist) {
            snappedX = 0;
            snapLines.push({ type: 'vertical', pos: 0, color: '#FF6B6B' });
          }
          // Right edge
          else if (Math.abs(x + width - this.canvasWidth) < dist) {
            snappedX = this.canvasWidth - width;
            snapLines.push({ type: 'vertical', pos: this.canvasWidth, color: '#FF6B6B' });
          }
          
          // Top edge
          if (Math.abs(y) < dist) {
            snappedY = 0;
            snapLines.push({ type: 'horizontal', pos: 0, color: '#FF6B6B' });
          }
          // Bottom edge
          else if (Math.abs(y + height - this.canvasHeight) < dist) {
            snappedY = this.canvasHeight - height;
            snapLines.push({ type: 'horizontal', pos: this.canvasHeight, color: '#FF6B6B' });
          }
          
          // Grid line snapping to canvas borders - enhanced magnetic grid
          if (this.showGrid) {
            // Snap to vertical grid lines near canvas borders
            for (let gridX = 0; gridX <= this.canvasWidth; gridX += this.gridSize) {
              // Snap image left edge to grid line
              if (Math.abs(x - gridX) < dist) {
                snappedX = gridX;
                snapLines.push({ type: 'vertical', pos: gridX, color: '#FFA500' });
                break;
              }
              // Snap image right edge to grid line
              if (Math.abs(x + width - gridX) < dist) {
                snappedX = gridX - width;
                snapLines.push({ type: 'vertical', pos: gridX, color: '#FFA500' });
                break;
              }
            }
            
            // Snap to horizontal grid lines near canvas borders
            for (let gridY = 0; gridY <= this.canvasHeight; gridY += this.gridSize) {
              // Snap image top edge to grid line
              if (Math.abs(y - gridY) < dist) {
                snappedY = gridY;
                snapLines.push({ type: 'horizontal', pos: gridY, color: '#FFA500' });
                break;
              }
              // Snap image bottom edge to grid line
              if (Math.abs(y + height - gridY) < dist) {
                snappedY = gridY - height;
                snapLines.push({ type: 'horizontal', pos: gridY, color: '#FFA500' });
                break;
              }
            }
          }
          
          // Image edge snapping
          for (let i = 0; i < this.node.imageConfigs.length; i++) {
            if (i === excludeIndex) continue;
            
            const otherConfig = this.node.imageConfigs[i];
            const otherBounds = this.getImageBounds(otherConfig, i);
            
            // Horizontal alignment (X-axis snapping)
            // Left to left
            if (Math.abs(x - otherBounds.x) < dist) {
              snappedX = otherBounds.x;
              snapLines.push({ type: 'vertical', pos: otherBounds.x, color: '#4ECDC4' });
            }
            // Right to right
            else if (Math.abs(x + width - (otherBounds.x + otherBounds.width)) < dist) {
              snappedX = otherBounds.x + otherBounds.width - width;
              snapLines.push({ type: 'vertical', pos: otherBounds.x + otherBounds.width, color: '#4ECDC4' });
            }
            // Left to right
            else if (Math.abs(x - (otherBounds.x + otherBounds.width)) < dist) {
              snappedX = otherBounds.x + otherBounds.width;
              snapLines.push({ type: 'vertical', pos: otherBounds.x + otherBounds.width, color: '#45B7D1' });
            }
            // Right to left
            else if (Math.abs(x + width - otherBounds.x) < dist) {
              snappedX = otherBounds.x - width;
              snapLines.push({ type: 'vertical', pos: otherBounds.x, color: '#45B7D1' });
            }
            
            // Vertical alignment (Y-axis snapping)
            // Top to top
            if (Math.abs(y - otherBounds.y) < dist) {
              snappedY = otherBounds.y;
              snapLines.push({ type: 'horizontal', pos: otherBounds.y, color: '#4ECDC4' });
            }
            // Bottom to bottom
            else if (Math.abs(y + height - (otherBounds.y + otherBounds.height)) < dist) {
              snappedY = otherBounds.y + otherBounds.height - height;
              snapLines.push({ type: 'horizontal', pos: otherBounds.y + otherBounds.height, color: '#4ECDC4' });
            }
            // Top to bottom
            else if (Math.abs(y - (otherBounds.y + otherBounds.height)) < dist) {
              snappedY = otherBounds.y + otherBounds.height;
              snapLines.push({ type: 'horizontal', pos: otherBounds.y + otherBounds.height, color: '#45B7D1' });
            }
            // Bottom to top
            else if (Math.abs(y + height - otherBounds.y) < dist) {
              snappedY = otherBounds.y - height;
              snapLines.push({ type: 'horizontal', pos: otherBounds.y, color: '#45B7D1' });
            }
          }
          
          return { x: snappedX, y: snappedY, snapLines };
        }
        
        getImageBounds(config, index) {
          // Match C++ processing pipeline exactly: resize → rotate → final bounds
          
          // Step 1: Calculate resize dimensions (matching C++ logic lines 206-218)
          let targetWidth, targetHeight;
          const originalWidth = config.inputWidth || 800;
          const originalHeight = config.inputHeight || 600;
          
          if (config.width > 0 || config.height > 0) {
            targetWidth = config.width > 0 ? config.width : originalWidth;
            targetHeight = config.height > 0 ? config.height : originalHeight;
            
            // Maintain aspect ratio if only one dimension specified (matching C++)
            if (config.width > 0 && (config.height <= 0 || !config.height)) {
              targetHeight = Math.round(targetWidth * originalHeight / originalWidth);
            } else if (config.height > 0 && (config.width <= 0 || !config.width)) {
              targetWidth = Math.round(targetHeight * originalWidth / originalHeight);
            }
          } else {
            // Keep original dimensions
            targetWidth = originalWidth;
            targetHeight = originalHeight;
          }
          
          // Step 2: Calculate rotation expansion (matching C++ logic lines 241-248)
          let finalWidth = targetWidth;
          let finalHeight = targetHeight;
          
          if (config.rotation && Math.abs(config.rotation) > 1e-3) {
            const normalizedAngle = ((config.rotation % 360) + 360) % 360;
            const eps = 1e-3;
            
            // Fast-path for 90-degree rotations (matching C++ fast-path)
            if (Math.abs(normalizedAngle) < eps || Math.abs(normalizedAngle - 360.0) < eps) {
              // 0 degrees - no size change
            } else if (Math.abs(normalizedAngle - 90.0) < eps) {
              // 90° rotation swaps dimensions
              finalWidth = targetHeight;
              finalHeight = targetWidth;
            } else if (Math.abs(normalizedAngle - 180.0) < eps) {
              // 180° rotation - no size change
            } else if (Math.abs(normalizedAngle - 270.0) < eps) {
              // 270° rotation swaps dimensions
              finalWidth = targetHeight;
              finalHeight = targetWidth;
            } else {
              // Arbitrary angles - calculate expanded bounding box (matching C++ formula)
              const radians = config.rotation * Math.PI / 180;
              const cosA = Math.abs(Math.cos(radians));
              const sinA = Math.abs(Math.sin(radians));
              finalWidth = Math.round(targetHeight * sinA + targetWidth * cosA);
              finalHeight = Math.round(targetHeight * cosA + targetWidth * sinA);
            }
          }
          
          return {
            x: config.x,
            y: config.y,
            width: finalWidth,
            height: finalHeight
          };
        }
        
        hitTestHandles(x, y) {
          if (this.selectedIndex < 0) return null;
          
          const config = this.node.imageConfigs[this.selectedIndex];
          const bounds = this.getImageBounds(config, this.selectedIndex);
          const h = this.handleSize;
          
          // Test rotation handle first
          const rotHandleX = bounds.x + bounds.width/2;
          const rotHandleY = bounds.y - 25;
          const rotDist = Math.sqrt((x - rotHandleX)**2 + (y - rotHandleY)**2);
          if (rotDist <= h) {
            return 'rotate';
          }
          
          // Test resize handles
          const handles = {
            'nw': { x: bounds.x - h/2, y: bounds.y - h/2 },
            'n':  { x: bounds.x + bounds.width/2 - h/2, y: bounds.y - h/2 },
            'ne': { x: bounds.x + bounds.width - h/2, y: bounds.y - h/2 },
            'e':  { x: bounds.x + bounds.width - h/2, y: bounds.y + bounds.height/2 - h/2 },
            'se': { x: bounds.x + bounds.width - h/2, y: bounds.y + bounds.height - h/2 },
            's':  { x: bounds.x + bounds.width/2 - h/2, y: bounds.y + bounds.height - h/2 },
            'sw': { x: bounds.x - h/2, y: bounds.y + bounds.height - h/2 },
            'w':  { x: bounds.x - h/2, y: bounds.y + bounds.height/2 - h/2 }
          };
          
          for (let [handleType, handle] of Object.entries(handles)) {
            if (x >= handle.x && x <= handle.x + h &&
                y >= handle.y && y <= handle.y + h) {
              return handleType;
            }
          }
          
          return null;
        }
        
        hitTest(x, y) {
          // First check handles if something is selected
          const handleHit = this.hitTestHandles(x, y);
          if (handleHit) return { type: 'handle', handle: handleHit, index: this.selectedIndex };
          
          // Test in reverse order (highest z-index first)
          const configs = [...this.node.imageConfigs].sort((a, b) => (b.zIndex || 0) - (a.zIndex || 0));
          
          for (let config of configs) {
            const originalIndex = this.node.imageConfigs.indexOf(config);
            const bounds = this.getImageBounds(config, originalIndex);
            
            if (x >= bounds.x && x <= bounds.x + bounds.width &&
                y >= bounds.y && y <= bounds.y + bounds.height) {
              return { type: 'image', index: originalIndex };
            }
          }
          return null;
        }
        
        handleMouseDown(e) {
          const pos = this.getMousePos(e);
          const hit = this.hitTest(pos.x, pos.y);
          
          if (hit && hit.type === 'handle') {
            // Handle interaction
            if (hit.handle === 'rotate') {
              this.isRotating = true;
              const config = this.node.imageConfigs[hit.index];
              const bounds = this.getImageBounds(config, hit.index);
              this.rotationCenter = { x: bounds.x + bounds.width/2, y: bounds.y + bounds.height/2 };
              this.originalRotation = config.rotation || 0;
            } else {
              this.isResizing = true;
              this.resizeHandle = hit.handle;
            }
            
            this.dragStartX = pos.x;
            this.dragStartY = pos.y;
            const config = this.node.imageConfigs[hit.index];
            this.originalBounds = {
              x: config.x,
              y: config.y,
              width: config.width || 100,
              height: config.height || 100
            };
          } else if (hit && hit.type === 'image') {
            // Image selection/drag
            this.selectedIndex = hit.index;
            this.isDragging = true;
            this.dragStartX = pos.x - this.node.imageConfigs[hit.index].x;
            this.dragStartY = pos.y - this.node.imageConfigs[hit.index].y;
            this.updatePropertiesPanel();
            this.render();
          } else {
            // Deselect
            this.selectedIndex = -1;
            this.updatePropertiesPanel();
            this.render();
          }
        }
        
        handleMouseMove(e) {
          const pos = this.getMousePos(e);
          
          if (this.isDragging && this.selectedIndex >= 0) {
            // Enhanced dragging with magnetic snapping
            const config = this.node.imageConfigs[this.selectedIndex];
            const bounds = this.getImageBounds(config, this.selectedIndex);
            
            let newX = pos.x - this.dragStartX;
            let newY = pos.y - this.dragStartY;
            
            // Apply magnetic snapping for dragging
            const magneticResult = this.magneticSnapPosition(newX, newY, bounds.width, bounds.height, this.selectedIndex);
            newX = magneticResult.x;
            newY = magneticResult.y;
            this.snapLines = magneticResult.snapLines;
            
            // Apply grid snapping if magnetic snapping didn't activate
            if (this.snapLines.length === 0) {
              const gridSnapped = this.snapToGridPos(newX, newY);
              newX = gridSnapped.x;
              newY = gridSnapped.y;
            }
            
            // Bounds checking
            newX = Math.max(0, Math.min(newX, this.canvasWidth - bounds.width));
            newY = Math.max(0, Math.min(newY, this.canvasHeight - bounds.height));
            
            config.x = newX;
            config.y = newY;
            
            this.updatePropertiesPanel();
            this.render();
            RED.nodes.dirty(true);
          } else if (this.isResizing && this.selectedIndex >= 0) {
            // Enhanced resize handling with aspect ratio preservation
            const config = this.node.imageConfigs[this.selectedIndex];
            const deltaX = pos.x - this.dragStartX;
            const deltaY = pos.y - this.dragStartY;
            
            let newBounds = { ...this.originalBounds };
            const preserveRatio = this.preserveAspectRatio && !this.shiftPressed;
            
            // Apply resize based on handle type with aspect ratio preservation
            switch (this.resizeHandle) {
              case 'nw':
                if (preserveRatio) {
                  // Use the larger change to maintain aspect ratio
                  const scaleX = Math.max(20, this.originalBounds.width - deltaX) / this.originalBounds.width;
                  const scaleY = Math.max(20, this.originalBounds.height - deltaY) / this.originalBounds.height;
                  const scale = Math.min(scaleX, scaleY);
                  
                  newBounds.width = Math.max(20, this.originalBounds.width * scale);
                  newBounds.height = Math.max(20, this.originalBounds.height * scale);
                  newBounds.x = this.originalBounds.x + (this.originalBounds.width - newBounds.width);
                  newBounds.y = this.originalBounds.y + (this.originalBounds.height - newBounds.height);
                } else {
                  newBounds.width = Math.max(20, this.originalBounds.width - deltaX);
                  newBounds.height = Math.max(20, this.originalBounds.height - deltaY);
                  newBounds.x = this.originalBounds.x + deltaX;
                  newBounds.y = this.originalBounds.y + deltaY;
                }
                break;
              case 'n':
                if (preserveRatio) {
                  const scale = Math.max(20, this.originalBounds.height - deltaY) / this.originalBounds.height;
                  newBounds.width = Math.max(20, this.originalBounds.width * scale);
                  newBounds.height = Math.max(20, this.originalBounds.height * scale);
                  newBounds.x = this.originalBounds.x + (this.originalBounds.width - newBounds.width) / 2;
                  newBounds.y = this.originalBounds.y + (this.originalBounds.height - newBounds.height);
                } else {
                  newBounds.height = Math.max(20, this.originalBounds.height - deltaY);
                  newBounds.y = this.originalBounds.y + deltaY;
                }
                break;
              case 'ne':
                if (preserveRatio) {
                  const scaleX = Math.max(20, this.originalBounds.width + deltaX) / this.originalBounds.width;
                  const scaleY = Math.max(20, this.originalBounds.height - deltaY) / this.originalBounds.height;
                  const scale = Math.min(scaleX, scaleY);
                  
                  newBounds.width = Math.max(20, this.originalBounds.width * scale);
                  newBounds.height = Math.max(20, this.originalBounds.height * scale);
                  newBounds.y = this.originalBounds.y + (this.originalBounds.height - newBounds.height);
                } else {
                  newBounds.width = Math.max(20, this.originalBounds.width + deltaX);
                  newBounds.height = Math.max(20, this.originalBounds.height - deltaY);
                  newBounds.y = this.originalBounds.y + deltaY;
                }
                break;
              case 'e':
                if (preserveRatio) {
                  const scale = Math.max(20, this.originalBounds.width + deltaX) / this.originalBounds.width;
                  newBounds.width = Math.max(20, this.originalBounds.width * scale);
                  newBounds.height = Math.max(20, this.originalBounds.height * scale);
                  newBounds.y = this.originalBounds.y + (this.originalBounds.height - newBounds.height) / 2;
                } else {
                  newBounds.width = Math.max(20, this.originalBounds.width + deltaX);
                }
                break;
              case 'se':
                if (preserveRatio) {
                  const scaleX = Math.max(20, this.originalBounds.width + deltaX) / this.originalBounds.width;
                  const scaleY = Math.max(20, this.originalBounds.height + deltaY) / this.originalBounds.height;
                  const scale = Math.min(scaleX, scaleY);
                  
                  newBounds.width = Math.max(20, this.originalBounds.width * scale);
                  newBounds.height = Math.max(20, this.originalBounds.height * scale);
                } else {
                  newBounds.width = Math.max(20, this.originalBounds.width + deltaX);
                  newBounds.height = Math.max(20, this.originalBounds.height + deltaY);
                }
                break;
              case 's':
                if (preserveRatio) {
                  const scale = Math.max(20, this.originalBounds.height + deltaY) / this.originalBounds.height;
                  newBounds.width = Math.max(20, this.originalBounds.width * scale);
                  newBounds.height = Math.max(20, this.originalBounds.height * scale);
                  newBounds.x = this.originalBounds.x + (this.originalBounds.width - newBounds.width) / 2;
                } else {
                  newBounds.height = Math.max(20, this.originalBounds.height + deltaY);
                }
                break;
              case 'sw':
                if (preserveRatio) {
                  const scaleX = Math.max(20, this.originalBounds.width - deltaX) / this.originalBounds.width;
                  const scaleY = Math.max(20, this.originalBounds.height + deltaY) / this.originalBounds.height;
                  const scale = Math.min(scaleX, scaleY);
                  
                  newBounds.width = Math.max(20, this.originalBounds.width * scale);
                  newBounds.height = Math.max(20, this.originalBounds.height * scale);
                  newBounds.x = this.originalBounds.x + (this.originalBounds.width - newBounds.width);
                } else {
                  newBounds.width = Math.max(20, this.originalBounds.width - deltaX);
                  newBounds.height = Math.max(20, this.originalBounds.height + deltaY);
                  newBounds.x = this.originalBounds.x + deltaX;
                }
                break;
              case 'w':
                if (preserveRatio) {
                  const scale = Math.max(20, this.originalBounds.width - deltaX) / this.originalBounds.width;
                  newBounds.width = Math.max(20, this.originalBounds.width * scale);
                  newBounds.height = Math.max(20, this.originalBounds.height * scale);
                  newBounds.x = this.originalBounds.x + (this.originalBounds.width - newBounds.width);
                  newBounds.y = this.originalBounds.y + (this.originalBounds.height - newBounds.height) / 2;
                } else {
                  newBounds.width = Math.max(20, this.originalBounds.width - deltaX);
                  newBounds.x = this.originalBounds.x + deltaX;
                }
                break;
            }
            
            // Apply bounds checking
            config.x = Math.max(0, Math.min(newBounds.x, this.canvasWidth - newBounds.width));
            config.y = Math.max(0, Math.min(newBounds.y, this.canvasHeight - newBounds.height));
            config.width = newBounds.width;
            config.height = newBounds.height;
            
            this.updatePropertiesPanel();
            this.render();
            RED.nodes.dirty(true);
          } else if (this.isRotating && this.selectedIndex >= 0) {
            // Rotation handling - mathematical standard (counterclockwise positive)
            const config = this.node.imageConfigs[this.selectedIndex];
            const angle = Math.atan2(pos.y - this.rotationCenter.y, pos.x - this.rotationCenter.x);
            // Convert to degrees with 0° pointing up (north), counterclockwise positive
            const degrees = (angle * 180 / Math.PI + 90) % 360;
            // Ensure angle is always positive
            const normalizedDegrees = degrees < 0 ? degrees + 360 : degrees;
            
            config.rotation = Math.round(normalizedDegrees);
            
            this.updatePropertiesPanel();
            this.render();
            RED.nodes.dirty(true);
          }
        }
        
        handleMouseUp(e) {
          this.isDragging = false;
          this.isResizing = false;
          this.isRotating = false;
          this.resizeHandle = null;
          this.originalBounds = null;
          this.snapLines = []; // Clear snap lines
          this.canvas.style.cursor = 'default';
          this.render(); // Re-render to clear snap lines
        }
        
        handleClick(e) {
          // Selection is handled in mousedown
        }
        
        updateCursor(e) {
          if (this.isDragging || this.isResizing || this.isRotating) return;
          
          const pos = this.getMousePos(e);
          const hit = this.hitTest(pos.x, pos.y);
          
          if (hit && hit.type === 'handle') {
            const cursors = {
              'nw': 'nw-resize', 'n': 'n-resize', 'ne': 'ne-resize',
              'e': 'e-resize', 'se': 'se-resize', 's': 's-resize',
              'sw': 'sw-resize', 'w': 'w-resize', 'rotate': 'crosshair'
            };
            this.canvas.style.cursor = cursors[hit.handle] || 'pointer';
          } else if (hit && hit.type === 'image') {
            this.canvas.style.cursor = 'move';
          } else {
            this.canvas.style.cursor = 'default';
          }
        }
        
        render() {
          const ctx = this.ctx;
          ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          
          // Scale context for display
          ctx.save();
          ctx.scale(this.scale, this.scale);
          
          // Draw background
          const bgColor = $("#node-input-backgroundColor").val() || '#000000';
          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
          
          // Draw grid
          if (this.showGrid) {
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.5;
            
            for (let x = 0; x <= this.canvasWidth; x += this.gridSize) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, this.canvasHeight);
              ctx.stroke();
            }
            
            for (let y = 0; y <= this.canvasHeight; y += this.gridSize) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(this.canvasWidth, y);
              ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
          }
          
          // Draw image placeholders (sorted by z-index)
          const sortedConfigs = [...this.node.imageConfigs]
            .map((config, index) => ({config, index}))
            .sort((a, b) => (a.config.zIndex || 0) - (b.config.zIndex || 0));
          
          sortedConfigs.forEach(({config, index}) => {
            this.drawImagePlaceholder(ctx, config, index);
          });
          
          // Draw selection handles for selected image
          if (this.selectedIndex >= 0) {
            this.drawSelectionHandles(ctx, this.node.imageConfigs[this.selectedIndex], this.selectedIndex);
          }
          
          // Draw magnetic snap lines for visual feedback
          this.drawSnapLines(ctx);
          
          // Draw aspect ratio indicator
          this.drawAspectRatioIndicator(ctx);
          
          ctx.restore();
        }
        
        drawImagePlaceholder(ctx, config, index) {
          const bounds = this.getImageBounds(config, index);
          const isSelected = index === this.selectedIndex;
          
          // Generate consistent color for array index
          const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#5F27CD'];
          const color = colors[config.arrayIndex % colors.length];
          
          ctx.save();
          
          // Calculate original image dimensions before rotation for visualization
          const originalWidth = config.inputWidth || 800;
          const originalHeight = config.inputHeight || 600;
          
          // Calculate resize dimensions (same logic as getImageBounds)
          let targetWidth, targetHeight;
          if (config.width > 0 || config.height > 0) {
            targetWidth = config.width > 0 ? config.width : originalWidth;
            targetHeight = config.height > 0 ? config.height : originalHeight;
            
            if (config.width > 0 && (config.height <= 0 || !config.height)) {
              targetHeight = Math.round(targetWidth * originalHeight / originalWidth);
            } else if (config.height > 0 && (config.width <= 0 || !config.width)) {
              targetWidth = Math.round(targetHeight * originalWidth / originalHeight);
            }
          } else {
            targetWidth = originalWidth;
            targetHeight = originalHeight;
          }
          
          // Calculate z-index for depth effects
          const zIndex = config.zIndex || 0;
          const maxZ = Math.max(...this.node.imageConfigs.map(cfg => cfg.zIndex || 0));
          const minZ = Math.min(...this.node.imageConfigs.map(cfg => cfg.zIndex || 0));
          const zRange = Math.max(1, maxZ - minZ);
          const normalizedZ = (zIndex - minZ) / zRange; // 0 to 1
          
          // Add depth shadow based on z-index (higher z = more prominent shadow)
          const shadowIntensity = normalizedZ * 0.5 + 0.1; // 0.1 to 0.6
          const shadowOffset = Math.round(normalizedZ * 4 + 2); // 2 to 6 pixels
          
          ctx.shadowColor = `rgba(0, 0, 0, ${shadowIntensity})`;
          ctx.shadowBlur = shadowOffset * 2;
          ctx.shadowOffsetX = shadowOffset;
          ctx.shadowOffsetY = shadowOffset;
          
          // Draw selection highlight background (glow effect)
          if (isSelected) {
            // Enhanced selection glow for better visibility
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            // Selection background highlight
            ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            ctx.fillRect(bounds.x - 6, bounds.y - 6, bounds.width + 12, bounds.height + 12);
          }
          
          // Draw the final bounding box (expanded for rotation) - now transparent padding
          if (config.rotation && Math.abs(config.rotation) > 1e-3) {
            // For rotated images, show transparent padding area with subtle pattern
            ctx.fillStyle = 'rgba(200, 200, 200, 0.1)'; // Very light gray for transparent area
            ctx.globalAlpha = 0.5;
            ctx.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
            ctx.globalAlpha = 1;
            
            // Add subtle diagonal pattern to indicate transparency
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([3, 3]);
            const spacing = 10;
            for (let i = -bounds.height; i < bounds.width; i += spacing) {
              ctx.beginPath();
              ctx.moveTo(bounds.x + i, bounds.y);
              ctx.lineTo(bounds.x + i + bounds.height, bounds.y + bounds.height);
              ctx.stroke();
            }
            ctx.setLineDash([]);
          }
          
          // Draw the actual rotated image area inside the bounding box
          if (config.rotation && Math.abs(config.rotation) > 1e-3) {
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate((config.rotation * Math.PI) / 180);
            
            // Draw the actual image rectangle (before expansion)
            ctx.fillStyle = color;
            ctx.globalAlpha = isSelected ? 0.9 : 0.7;
            ctx.fillRect(-targetWidth / 2, -targetHeight / 2, targetWidth, targetHeight);
            
            // Draw border around actual image
            ctx.strokeStyle = isSelected ? '#000' : '#333';
            ctx.lineWidth = isSelected ? 2 : 1;
            ctx.globalAlpha = 1;
            ctx.strokeRect(-targetWidth / 2, -targetHeight / 2, targetWidth, targetHeight);
            
            ctx.resetTransform();
            ctx.scale(this.scale, this.scale); // Restore canvas scaling
          } else {
            // No rotation - draw normally
            ctx.fillStyle = color;
            ctx.globalAlpha = isSelected ? 0.9 : 0.7;
            ctx.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
            
            ctx.strokeStyle = isSelected ? '#000' : '#333';
            ctx.lineWidth = isSelected ? 2 : 1;
            ctx.globalAlpha = 1;
            ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
          }
          
          // Draw expanded bounding box border
          if (isSelected) {
            // Double border for selection on the expanded area
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            ctx.globalAlpha = 1;
            ctx.strokeRect(bounds.x - 2, bounds.y - 2, bounds.width + 4, bounds.height + 4);
          }
          
          // Draw the final bounds border
          ctx.strokeStyle = '#666';
          ctx.lineWidth = 1;  
          ctx.setLineDash([5, 5]); // Dashed line to show it's the expanded bounds
          ctx.globalAlpha = 0.8;
          ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
          ctx.setLineDash([]); // Reset line dash
          
          // Draw labels with better contrast
          ctx.fillStyle = isSelected ? '#000' : '#333';
          ctx.font = isSelected ? 'bold 12px Arial' : '12px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // White text outline for better readability
          if (isSelected) {
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.strokeText(
              `Image ${config.arrayIndex}`,
              bounds.x + bounds.width / 2,
              bounds.y + bounds.height / 2 - 8
            );
          }
          
          ctx.fillText(
            `Image ${config.arrayIndex} (Z:${zIndex})`,
            bounds.x + bounds.width / 2,
            bounds.y + bounds.height / 2 - 16
          );
          
          // Draw dimensions - show both original and final dimensions if different
          ctx.font = isSelected ? 'bold 10px Arial' : '10px Arial';
          
          const dimensionText = config.rotation && Math.abs(config.rotation) > 1e-3 
            ? `${targetWidth}×${targetHeight} → ${bounds.width}×${bounds.height}`
            : `${bounds.width}×${bounds.height}`;
          
          if (isSelected) {
            ctx.strokeText(
              dimensionText,
              bounds.x + bounds.width / 2,
              bounds.y + bounds.height / 2
            );
          }
          
          ctx.fillText(
            dimensionText,
            bounds.x + bounds.width / 2,
            bounds.y + bounds.height / 2
          );
          
          // Draw rotation indicator
          if (config.rotation && config.rotation !== 0) {
            if (isSelected) {
              ctx.strokeText(
                `${config.rotation}°`,
                bounds.x + bounds.width / 2,
                bounds.y + bounds.height / 2 + 16
              );
            }
            
            ctx.fillText(
              `${config.rotation}°`,
              bounds.x + bounds.width / 2,
              bounds.y + bounds.height / 2 + 16
            );
          }
          
          // Draw z-index indicator badge in top-right corner
          const badgeSize = 16;
          const badgeX = bounds.x + bounds.width - badgeSize - 2;
          const badgeY = bounds.y + 2;
          
          // Reset shadow for badge
          ctx.shadowColor = 'transparent';
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
          
          // Badge background (color-coded by z-index level)
          const badgeAlpha = normalizedZ * 0.6 + 0.4; // 0.4 to 1.0
          ctx.fillStyle = `rgba(0, 100, 200, ${badgeAlpha})`;
          ctx.fillRect(badgeX, badgeY, badgeSize, badgeSize);
          
          // Badge border
          ctx.strokeStyle = '#003366';
          ctx.lineWidth = 1;
          ctx.strokeRect(badgeX, badgeY, badgeSize, badgeSize);
          
          // Z-index number
          ctx.fillStyle = '#FFFFFF';
          ctx.font = 'bold 10px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(
            zIndex.toString(),
            badgeX + badgeSize / 2,
            badgeY + badgeSize / 2
          );
          
          ctx.restore();
        }
        
        drawSelectionHandles(ctx, config, index) {
          const bounds = this.getImageBounds(config, index);
          const h = this.handleSize;
          
          ctx.save();
          
          // Don't rotate handles - they stay aligned to screen
          // Apply same scaling as main rendering
          
          // Define handle positions
          const handles = {
            'nw': { x: bounds.x - h/2, y: bounds.y - h/2 },
            'n':  { x: bounds.x + bounds.width/2 - h/2, y: bounds.y - h/2 },
            'ne': { x: bounds.x + bounds.width - h/2, y: bounds.y - h/2 },
            'e':  { x: bounds.x + bounds.width - h/2, y: bounds.y + bounds.height/2 - h/2 },
            'se': { x: bounds.x + bounds.width - h/2, y: bounds.y + bounds.height - h/2 },
            's':  { x: bounds.x + bounds.width/2 - h/2, y: bounds.y + bounds.height - h/2 },
            'sw': { x: bounds.x - h/2, y: bounds.y + bounds.height - h/2 },
            'w':  { x: bounds.x - h/2, y: bounds.y + bounds.height/2 - h/2 }
          };
          
          // Draw resize handles
          ctx.fillStyle = '#FFD700';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1;
          
          Object.values(handles).forEach(handle => {
            ctx.fillRect(handle.x, handle.y, h, h);
            ctx.strokeRect(handle.x, handle.y, h, h);
          });
          
          // Draw rotation handle
          const rotHandleX = bounds.x + bounds.width/2;
          const rotHandleY = bounds.y - 25;
          
          // Connection line to rotation handle
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 2;
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.moveTo(bounds.x + bounds.width/2, bounds.y);
          ctx.lineTo(rotHandleX, rotHandleY + h/2);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Rotation handle (circle)
          ctx.fillStyle = '#FF6B6B';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(rotHandleX, rotHandleY, h/2, 0, 2 * Math.PI);
          ctx.fill();
          ctx.stroke();
          
          // Rotation symbol
          ctx.fillStyle = '#FFF';
          ctx.font = 'bold 10px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('↻', rotHandleX, rotHandleY);
          
          ctx.restore();
        }
        
        // Draw magnetic snap lines for visual feedback
        drawSnapLines(ctx) {
          if (!this.snapLines || this.snapLines.length === 0) return;
          
          ctx.save();
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.globalAlpha = 0.8;
          
          this.snapLines.forEach(line => {
            ctx.strokeStyle = line.color;
            ctx.beginPath();
            
            if (line.type === 'vertical') {
              ctx.moveTo(line.pos, 0);
              ctx.lineTo(line.pos, this.canvasHeight);
            } else if (line.type === 'horizontal') {
              ctx.moveTo(0, line.pos);
              ctx.lineTo(this.canvasWidth, line.pos);
            }
            
            ctx.stroke();
          });
          
          ctx.restore();
        }
        
        // Draw aspect ratio preservation indicator
        drawAspectRatioIndicator(ctx) {
          if (!this.isResizing || this.selectedIndex < 0) return;
          
          ctx.save();
          
          // Draw indicator in top-right corner
          const indicatorX = this.canvasWidth - 100;
          const indicatorY = 20;
          
          // Background
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.roundRect = ctx.roundRect || function(x, y, w, h, r) {
            this.beginPath();
            this.moveTo(x + r, y);
            this.arcTo(x + w, y, x + w, y + h, r);
            this.arcTo(x + w, y + h, x, y + h, r);
            this.arcTo(x, y + h, x, y, r);
            this.arcTo(x, y, x + w, y, r);
            this.closePath();
          };
          ctx.roundRect(indicatorX - 10, indicatorY - 5, 90, 25, 5);
          ctx.fill();
          
          // Text
          ctx.fillStyle = '#FFF';
          ctx.font = '12px Arial';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          
          const preserveRatio = this.preserveAspectRatio && !this.shiftPressed;
          const text = preserveRatio ? '🔒 Aspect Locked' : '🔓 Free Resize';
          ctx.fillText(text, indicatorX - 5, indicatorY + 7);
          
          ctx.restore();
        }
        
        updatePropertiesPanel() {
          const panel = $('#selected-properties');
          
          if (this.selectedIndex >= 0) {
            const config = this.node.imageConfigs[this.selectedIndex];
            panel.show();
            
            // Input dimensions
            $('#prop-array-index').val(config.arrayIndex || 0);
            $('#prop-input-width').val(config.inputWidth || 800);
            $('#prop-input-height').val(config.inputHeight || 600);
            
            // Resize dimensions
            $('#prop-width').val(config.width || '');
            $('#prop-height').val(config.height || '');
            
            // Transform
            $('#prop-rotation').val(config.rotation || 0);
            $('#prop-z-index').val(config.zIndex || this.selectedIndex);
            
            // Position
            $('#prop-x').val(config.x || 0);
            $('#prop-y').val(config.y || 0);
            
            // Calculate and display computed dimensions
            const originalWidth = config.inputWidth || 800;
            const originalHeight = config.inputHeight || 600;
            
            // Step 1: Calculate resize dimensions
            let targetWidth, targetHeight;
            if (config.width > 0 || config.height > 0) {
              targetWidth = config.width > 0 ? config.width : originalWidth;
              targetHeight = config.height > 0 ? config.height : originalHeight;
              
              if (config.width > 0 && (config.height <= 0 || !config.height)) {
                targetHeight = Math.round(targetWidth * originalHeight / originalWidth);
              } else if (config.height > 0 && (config.width <= 0 || !config.width)) {
                targetWidth = Math.round(targetHeight * originalWidth / originalHeight);
              }
            } else {
              targetWidth = originalWidth;
              targetHeight = originalHeight;
            }
            
            $('#prop-computed-resize').val(`${targetWidth} × ${targetHeight}`);
            
            // Step 2: Calculate final dimensions after rotation
            const bounds = this.getImageBounds(config, this.selectedIndex);
            $('#prop-computed-final').val(`${bounds.width} × ${bounds.height}`);
            
            // Calculate expansion factor
            const originalArea = targetWidth * targetHeight;
            const finalArea = bounds.width * bounds.height;
            const expansionFactor = (finalArea / originalArea).toFixed(2);
            $('#prop-expansion-factor').val(`${expansionFactor}×`);
            
            $('#remove-selected-config').prop('disabled', false);
          } else {
            panel.hide();
            $('#remove-selected-config').prop('disabled', true);
          }
        }
        
        updateConfigFromProperties() {
          if (this.selectedIndex >= 0) {
            const config = this.node.imageConfigs[this.selectedIndex];
            
            // Input dimensions
            config.arrayIndex = parseInt($('#prop-array-index').val()) || 0;
            config.inputWidth = parseInt($('#prop-input-width').val()) || 800;
            config.inputHeight = parseInt($('#prop-input-height').val()) || 600;
            
            // Resize dimensions
            const widthVal = $('#prop-width').val();
            config.width = widthVal === '' ? null : parseInt(widthVal);
            
            const heightVal = $('#prop-height').val();
            config.height = heightVal === '' ? null : parseInt(heightVal);
            
            // Transform
            config.rotation = parseFloat($('#prop-rotation').val()) || 0;
            config.zIndex = parseInt($('#prop-z-index').val()) || 0;
            
            // Position
            config.x = parseFloat($('#prop-x').val()) || 0;
            config.y = parseFloat($('#prop-y').val()) || 0;
            
            this.render();
            RED.nodes.dirty(true);
          }
        }
      }
      
      // Initialize canvas editor with delay to ensure container is sized
      setTimeout(() => {
        const canvasEditor = new MosaicCanvasEditor(document.getElementById('mosaic-canvas'), node);
        
        // Store reference for event handlers
        node.canvasEditor = canvasEditor;
        
        // Event handlers for canvas controls
        $('#add-image-config').on('click', function() {
          node.imageConfigs.push({
            arrayIndex: node.imageConfigs.length,
            inputWidth: 800,
            inputHeight: 600,
            x: 50 + (node.imageConfigs.length * 20),
            y: 50 + (node.imageConfigs.length * 20),
            width: 200,
            height: 150,
            rotation: 0,
            zIndex: node.imageConfigs.length
          });
          canvasEditor.render();
          RED.nodes.dirty(true);
        });
        
        $('#remove-selected-config').on('click', function() {
          if (canvasEditor.selectedIndex >= 0) {
            node.imageConfigs.splice(canvasEditor.selectedIndex, 1);
            canvasEditor.selectedIndex = -1;
            canvasEditor.updatePropertiesPanel();
            canvasEditor.render();
            RED.nodes.dirty(true);
          }
        });
        
        $('#show-grid').on('change', function() {
          canvasEditor.showGrid = $(this).is(':checked');
          canvasEditor.render();
        });
        
        $('#snap-to-grid').on('change', function() {
          canvasEditor.snapToGrid = $(this).is(':checked');
        });
        
        $('#magnetic-snap').on('change', function() {
          canvasEditor.magneticSnap = $(this).is(':checked');
        });
        
        $('#preserve-aspect').on('change', function() {
          canvasEditor.preserveAspectRatio = $(this).is(':checked');
        });
        
        $('#duplicate-selected').on('click', function() {
          if (canvasEditor.selectedIndex >= 0) {
            const original = node.imageConfigs[canvasEditor.selectedIndex];
            const duplicate = {
              arrayIndex: original.arrayIndex,
              inputWidth: original.inputWidth,
              inputHeight: original.inputHeight,
              x: original.x + 30,
              y: original.y + 30,
              width: original.width,
              height: original.height,
              rotation: original.rotation,
              zIndex: node.imageConfigs.length
            };
            node.imageConfigs.push(duplicate);
            canvasEditor.render();
            RED.nodes.dirty(true);
          }
        });
        
        // Z-Index control buttons
        $('#bring-to-front').on('click', function() {
          if (canvasEditor.selectedIndex >= 0) {
            const maxZ = Math.max(...node.imageConfigs.map(cfg => cfg.zIndex || 0));
            node.imageConfigs[canvasEditor.selectedIndex].zIndex = maxZ + 1;
            canvasEditor.updatePropertiesPanel();
            canvasEditor.render();
            RED.nodes.dirty(true);
          }
        });
        
        $('#send-to-back').on('click', function() {
          if (canvasEditor.selectedIndex >= 0) {
            const minZ = Math.min(...node.imageConfigs.map(cfg => cfg.zIndex || 0));
            node.imageConfigs[canvasEditor.selectedIndex].zIndex = minZ - 1;
            canvasEditor.updatePropertiesPanel();
            canvasEditor.render();
            RED.nodes.dirty(true);
          }
        });
        
        $('#move-up').on('click', function() {
          if (canvasEditor.selectedIndex >= 0) {
            const currentZ = node.imageConfigs[canvasEditor.selectedIndex].zIndex || 0;
            node.imageConfigs[canvasEditor.selectedIndex].zIndex = currentZ + 1;
            canvasEditor.updatePropertiesPanel();
            canvasEditor.render();
            RED.nodes.dirty(true);
          }
        });
        
        $('#move-down').on('click', function() {
          if (canvasEditor.selectedIndex >= 0) {
            const currentZ = node.imageConfigs[canvasEditor.selectedIndex].zIndex || 0;
            node.imageConfigs[canvasEditor.selectedIndex].zIndex = currentZ - 1;
            canvasEditor.updatePropertiesPanel();
            canvasEditor.render();
            RED.nodes.dirty(true);
          }
        });
        
        // Properties panel event handlers
        $('#selected-properties input').on('input', function() {
          canvasEditor.updateConfigFromProperties();
        });
        
        // Background color change
        $('#node-input-backgroundColor').on('change', function() {
          canvasEditor.render();
        });
      }, 100);
    }
  });

  // Debug image display renderer - shared across all image processing nodes
  if (!window.debugImageRendererInitialized) {
      window.debugImageRendererInitialized = true;
      
      (function() {
          var isSubscribed = false;
          
          function subscribeToDebugImages() {
              if (isSubscribed || typeof RED === 'undefined' || !RED.comms) return;
              isSubscribed = true;
              
              RED.comms.subscribe('debug-image', function(event, data) {
                  if (!data || !data.id) return;
                  
                  try {
                      renderDebugImage(data);
                  } catch (err) {
                      console.warn('Debug image render error:', err);
                  }
              });
          }
          
          function renderDebugImage(data) {
              const nodeId = data.id;
              const base64Data = data.data;
              const format = data.format || 'unknown';
              const mimeType = data.mimeType || 'jpeg';
              
              if (!base64Data) {
                  removeDebugImage(nodeId);
                  return;
              }
              
              const nodeElement = document.getElementById(nodeId);
              if (!nodeElement) return;
              
              let debugContainer = document.getElementById('debug-img-container-' + nodeId);
              
              if (!debugContainer) {
                  // Create SVG foreignObject to embed HTML content in SVG
                  debugContainer = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                  debugContainer.id = 'debug-img-container-' + nodeId;
                  debugContainer.setAttribute('x', '70');
                  debugContainer.setAttribute('y', '5');
                  debugContainer.setAttribute('width', '120');
                  debugContainer.setAttribute('height', '120');
                  debugContainer.style.overflow = 'visible';
                  
                  // Create simple image directly inside foreignObject
                  const img = document.createElement('img');
                  img.id = 'debug-img-' + nodeId;
                  img.style.width = '100%';
                  img.style.height = 'auto';
                  img.style.display = 'block';
                  img.style.cursor = 'pointer';
                  img.style.maxHeight = '100px';
                  img.style.maxWidth = '100px';
                  
                  img.onclick = function() {
                      removeDebugImage(nodeId);
                  };
                  
                  debugContainer.appendChild(img);
                  nodeElement.appendChild(debugContainer);
              }
              
              const img = document.getElementById('debug-img-' + nodeId);
              
              if (img) {
                  img.src = `data:image/${mimeType};base64,${base64Data}`;
                  img.title = 'Debug image (click to hide)';
              }
          }
          
          function removeDebugImage(nodeId) {
              const debugContainer = document.getElementById('debug-img-container-' + nodeId);
              if (debugContainer) {
                  debugContainer.remove();
              }
          }
          
          function initializeWhenReady() {
              if (typeof RED !== 'undefined' && RED.comms) {
                  subscribeToDebugImages();
                  
                  // Clean up orphaned debug images periodically
                  setInterval(function() {
                      const debugContainers = document.querySelectorAll('[id^="debug-img-container-"]');
                      debugContainers.forEach(container => {
                          const nodeId = container.id.replace('debug-img-container-', '');
                          const nodeElement = document.getElementById(nodeId);
                          if (!nodeElement) {
                              container.remove();
                          }
                      });
                  }, 5000);
              } else {
                  setTimeout(initializeWhenReady, 100);
              }
          }
          
          if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', initializeWhenReady);
          } else {
              initializeWhenReady();
          }
      })();
  }
</script>

<!-- 2 ▸ Edit‑dialog template -->
<script type="text/x-red" data-template-name="advanced-mosaic">

<!-- Name -->
<div class="form-row">
  <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
  <input type="text" id="node-input-name" placeholder="Name">
</div>

<hr>

<!-- STANDARD I/O SECTION -->
<div class="form-row">
  <label for="node-input-inputPath"><i class="fa fa-sign-in"></i> Input from</label>
  <input type="text" id="node-input-inputPath" style="width: 70%;">
  <input type="hidden" id="node-input-inputPathType">
</div>
<div class="form-row">
  <label for="node-input-outputPath"><i class="fa fa-sign-out"></i> Output to</label>
  <input type="text" id="node-input-outputPath" style="width: 70%;">
  <input type="hidden" id="node-input-outputPathType">
</div>
<div class="form-row">
  <label for="node-input-outputFormat"><i class="fa fa-file-image-o"></i> Output Format</label>
  <select id="node-input-outputFormat" style="width: 200px;">
    <option value="raw">Raw (fastest)</option>
    <option value="jpg">JPEG</option>
    <option value="png">PNG</option>
    <option value="webp">WebP</option>
  </select>
</div>
<div class="form-row" id="quality-row">
  <label for="node-input-outputQuality"><i class="fa fa-sliders"></i> Quality</label>
  <input type="number" id="node-input-outputQuality" min="1" max="100" value="90" style="width: 70px;">
  <span style="margin-left: 10px; color: #666;">1-100 (JPG/WebP only)</span>
</div>
<div class="form-row" id="png-optimize-row" style="display: none;">
  <label for="node-input-pngOptimize"><i class="fa fa-compress"></i> PNG Optimize</label>
  <input type="checkbox" id="node-input-pngOptimize" style="display:inline-block; width:auto; vertical-align:baseline;">
  <label for="node-input-pngOptimize" style="width:auto; margin-left:5px;">Compress PNG (slower, smaller file)</label>
</div>

<!-- Debug Configuration -->
<div class="form-row">
  <label for="node-input-debugEnabled"><i class="fa fa-bug"></i> Debug</label>
  <input type="checkbox" id="node-input-debugEnabled" style="display:inline-block; width:auto; vertical-align:baseline;">
  <label for="node-input-debugEnabled" style="width:auto; margin-left:5px;">Show processed image</label>
</div>
<div class="form-row" id="debug-width-row" style="display: none;">
  <label for="node-input-debugWidth"><i class="fa fa-arrows-h"></i> Debug Width</label>
  <input type="text" id="node-input-debugWidth" style="width: 120px;">
  <input type="hidden" id="node-input-debugWidthType">
  <span style="margin-left: 10px; color: #666;">pixels</span>
</div>

<hr>

<!-- CANVAS CONFIGURATION -->
<div class="form-row">
  <label for="node-input-canvasWidth"><i class="fa fa-arrows-h"></i> Canvas Width</label>
  <input type="text" id="node-input-canvasWidth" style="width: 70%;" placeholder="800">
  <input type="hidden" id="node-input-canvasWidthType">
</div>
<div class="form-row">
  <label for="node-input-canvasHeight"><i class="fa fa-arrows-v"></i> Canvas Height</label>
  <input type="text" id="node-input-canvasHeight" style="width: 70%;" placeholder="600">
  <input type="hidden" id="node-input-canvasHeightType">
</div>
<div class="form-row">
  <label for="node-input-backgroundColor"><i class="fa fa-paint-brush"></i> Background Color</label>
  <input type="color" id="node-input-backgroundColor" style="width: 70px; height: 30px;">
</div>


<hr>

<!-- INTERACTIVE CANVAS EDITOR -->
<div class="form-row">
  <label style="width: 100%; margin-bottom: 10px;"><i class="fa fa-th-large"></i> Visual Canvas Editor</label>
  
  <!-- Canvas Controls -->
  <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
    <button type="button" id="add-image-config" style="background: #4CAF50; color: white; border: none; padding: 6px 12px; cursor: pointer; font-size: 12px;">Add Image</button>
    <button type="button" id="remove-selected-config" style="background: #ff4444; color: white; border: none; padding: 6px 12px; cursor: pointer; font-size: 12px;" disabled>Remove Selected</button>
    <label style="display: flex; align-items: center; gap: 5px; margin-left: auto;">
      <input type="checkbox" id="show-grid" checked> Show Grid
    </label>
    <label style="display: flex; align-items: center; gap: 5px;">
      <input type="checkbox" id="snap-to-grid" checked> Snap to Grid
    </label>
    <label style="display: flex; align-items: center; gap: 5px;">
      <input type="checkbox" id="magnetic-snap" checked> Magnetic Snap
    </label>
    <label style="display: flex; align-items: center; gap: 5px;">
      <input type="checkbox" id="preserve-aspect" checked> Lock Aspect Ratio
    </label>
  </div>
  
  <!-- Canvas Container -->
  <div id="canvas-container" style="border: 2px solid #ddd; background: #f9f9f9; position: relative; margin-bottom: 10px; width: 100%; min-height: 300px; display: flex; justify-content: center; align-items: center;">
    <canvas id="mosaic-canvas" width="400" height="300" style="display: block; cursor: default; border: 1px solid #ccc;"></canvas>
  </div>
  
  <!-- Selected Image Properties -->
  <div id="selected-properties" style="display: none; background: #f0f0f0; padding: 10px; border-radius: 4px; font-size: 12px;">
    <strong>Selected Image Properties:</strong>
    
    <!-- Input Dimensions Section -->
    <div style="background: #e8f4fd; padding: 8px; margin: 8px 0; border-radius: 4px;">
      <strong style="color: #1976d2;">Input Dimensions (Original Image):</strong>
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 8px;">
        <div>
          <label>Array Index:</label>
          <input type="number" id="prop-array-index" min="0" style="width: 100%; font-size: 11px;">
        </div>
        <div>
          <label>Input Width:</label>
          <input type="number" id="prop-input-width" min="1" style="width: 100%; font-size: 11px;" placeholder="800">
        </div>
        <div>
          <label>Input Height:</label>
          <input type="number" id="prop-input-height" min="1" style="width: 100%; font-size: 11px;" placeholder="600">
        </div>
      </div>
    </div>
    
    <!-- Resize & Transform Section -->
    <div style="background: #fff3e0; padding: 8px; margin: 8px 0; border-radius: 4px;">
      <strong style="color: #f57c00;">Resize & Transform:</strong>
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 8px;">
        <div>
          <label>Resize Width:</label>
          <input type="number" id="prop-width" min="1" style="width: 100%; font-size: 11px;" placeholder="Keep original">
        </div>
        <div>
          <label>Resize Height:</label>
          <input type="number" id="prop-height" min="1" style="width: 100%; font-size: 11px;" placeholder="Keep original">
        </div>
        <div>
          <label>Rotation (°):</label>
          <input type="number" id="prop-rotation" step="any" style="width: 100%; font-size: 11px;">
        </div>
      </div>
    </div>
    
    <!-- Computed Final Dimensions Section -->
    <div style="background: #e8f5e8; padding: 8px; margin: 8px 0; border-radius: 4px;">
      <strong style="color: #2e7d32;">Final Computed Dimensions:</strong>
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 8px;">
        <div>
          <label>After Resize:</label>
          <input type="text" id="prop-computed-resize" readonly style="width: 100%; font-size: 11px; background: #f5f5f5;" placeholder="Computed...">
        </div>
        <div>
          <label>After Rotation:</label>
          <input type="text" id="prop-computed-final" readonly style="width: 100%; font-size: 11px; background: #f5f5f5;" placeholder="Computed...">
        </div>
        <div>
          <label>Expansion Factor:</label>
          <input type="text" id="prop-expansion-factor" readonly style="width: 100%; font-size: 11px; background: #f5f5f5;" placeholder="1.0x">
        </div>
      </div>
    </div>
    
    <!-- Position Section -->
    <div style="background: #f3e5f5; padding: 8px; margin: 8px 0; border-radius: 4px;">
      <strong style="color: #7b1fa2;">Position & Actions:</strong>
      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 8px;">
        <div>
          <label>X Position:</label>
          <input type="number" id="prop-x" step="any" style="width: 100%; font-size: 11px;">
        </div>
        <div>
          <label>Y Position:</label>
          <input type="number" id="prop-y" step="any" style="width: 100%; font-size: 11px;">
        </div>
        <div>
          <label>Actions:</label>
          <div style="display: flex; gap: 4px; flex-wrap: wrap;">
            <button type="button" id="duplicate-selected" style="background: #2196F3; color: white; border: none; padding: 4px 8px; cursor: pointer; font-size: 10px;">Duplicate</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Layering Control Section -->
    <div style="background: #fff8e1; padding: 8px; margin: 8px 0; border-radius: 4px;">
      <strong style="color: #f57c00;">Layer Control (Z-Index):</strong>
      <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 10px; margin-top: 8px;">
        <div>
          <label>Z-Index:</label>
          <input type="number" id="prop-z-index" style="width: 100%; font-size: 11px;">
        </div>
        <div>
          <label>Layer Actions:</label>
          <div style="display: flex; gap: 4px; flex-wrap: wrap;">
            <button type="button" id="bring-to-front" style="background: #4CAF50; color: white; border: none; padding: 4px 8px; cursor: pointer; font-size: 10px;">Bring to Front</button>
            <button type="button" id="send-to-back" style="background: #FF9800; color: white; border: none; padding: 4px 8px; cursor: pointer; font-size: 10px;">Send to Back</button>
            <button type="button" id="move-up" style="background: #2196F3; color: white; border: none; padding: 4px 8px; cursor: pointer; font-size: 10px;">Move Up</button>
            <button type="button" id="move-down" style="background: #9C27B0; color: white; border: none; padding: 4px 8px; cursor: pointer; font-size: 10px;">Move Down</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="form-tips">
  <b>Enhanced Canvas Editor Instructions:</b>
  <ul>
    <li><b>Add Image:</b> Click "Add Image" to create a new placeholder rectangle</li>
    <li><b>Select & Drag:</b> Click on any placeholder to select it, then drag to reposition with magnetic snapping</li>
    <li><b>Resize with Aspect Ratio:</b> Drag resize handles to resize - aspect ratio is preserved by default, hold Shift to resize freely</li>
    <li><b>Accurate Preview:</b> The canvas shows exact dimensions matching the C++ processing pipeline</li>
    <li><b>Transparent Rotation:</b> Rotated images use transparent padding (diagonal pattern) allowing layered compositions</li>
    <li><b>Properties Panel:</b> Shows computed dimensions after resize and rotation, plus expansion factors</li>
    <li><b>Enhanced Grid Snapping:</b> Magnetic snap to grid lines, canvas borders, and other image edges</li>
    <li><b>Z-Index Control:</b> Visual depth indicators with easy layer management buttons (bring to front, send to back)</li>
    <li><b>Aspect Ratio Lock:</b> Toggle "Lock Aspect Ratio" to control default resize behavior</li>
    <li><b>Visual Feedback:</b> Colored snap lines appear during dragging, aspect ratio indicator shows during resize</li>
    <li><b>Color Coding:</b> Each array index has a unique color for easy identification</li>
    <li><b>Duplicate:</b> Use "Duplicate" button to copy the selected image configuration</li>
  </ul>
</div>
</script>

<!-- 3 ▸ Help panel -->
<script type="text/x-red" data-help-name="advanced-mosaic">
<p><b>rosepetal-advanced-mosaic</b> creates composite images with per-image transformations including resize, rotate, and positioning. This advanced node extends the basic mosaic functionality by allowing individual transformation of each image before placement on the canvas.</p>

<h3>Details</h3>
<p>This node processes arrays of images and applies individual transformations (resize, rotate) to each image before placing them on a customizable canvas. Each image can be independently resized, rotated, and positioned using an interactive visual canvas editor with drag-and-drop functionality.</p>

<h3>Properties</h3>
<dl class="message-properties">
  <dt>Input from <span class="property-type">string</span></dt>
  <dd>Message property path containing the input image array.</dd>
  
  <dt>Output to <span class="property-type">string</span></dt>
  <dd>Message property path where the composite image will be stored.</dd>
  
  <dt>Output Format <span class="property-type">string</span></dt>
  <dd>Format for the output image: <code>raw</code> (fastest), <code>jpg</code>, <code>png</code>, or <code>webp</code>.</dd>
  
  <dt>Quality <span class="property-type">number</span></dt>
  <dd>Compression quality (1-100) for JPEG and WebP formats.</dd>
  
  <dt>Canvas Width/Height <span class="property-type">number|string</span></dt>
  <dd>Dimensions of the output canvas in pixels. Supports dynamic values from context.</dd>
  
  <dt>Background Color <span class="property-type">color</span></dt>
  <dd>Canvas background color in hex format.</dd>
  
  <dt>Normalized Coords <span class="property-type">boolean</span></dt>
  <dd>When enabled, position coordinates use normalized values (0.0-1.0).</dd>
  
  <dt>Visual Canvas Editor <span class="property-type">interactive</span></dt>
  <dd>Interactive canvas interface for visually configuring image transformations with drag-and-drop positioning, magnetic helpers, and real-time preview.</dd>
</dl>

<h3>Image Transformations</h3>
<h4>Resize Options</h4>
<ul>
  <li><b>Absolute Sizing:</b> Set specific width and height in pixels</li>
  <li><b>Aspect Ratio Preservation:</b> Specify only width or height to maintain proportions</li>
  <li><b>Original Size:</b> Leave width/height empty to use original dimensions</li>
</ul>

<h4>Rotation System</h4>
<ul>
  <li><b>Arbitrary Angles:</b> Rotate by any angle in degrees (counterclockwise positive)</li>
  <li><b>Optimized 90° Rotations:</b> Fast-path processing for 90°, 180°, 270°</li>
  <li><b>Transparent Padding:</b> Rotation expansion uses transparent padding for layered compositions</li>
  <li><b>Alpha Blending:</b> Rotated images blend seamlessly with underlying content</li>
</ul>

<h4>Layering Control</h4>
<ul>
  <li><b>Z-Index Ordering:</b> Control which images appear on top</li>
  <li><b>Automatic Z-Assignment:</b> Default ordering based on configuration sequence</li>
</ul>

<h3>Performance Optimizations</h3>
<ul>
  <li><b>C++ Backend:</b> High-performance OpenCV-based processing with SIMD acceleration</li>
  <li><b>Transformation Pipeline:</b> Optimized resize → rotate → place sequence</li>
  <li><b>Zero-Copy Operations:</b> Minimal memory allocation and copying</li>
  <li><b>Parallel Processing:</b> Multiple images processed concurrently when beneficial</li>
  <li><b>Fast-Path Rotations:</b> Optimized handling for common rotation angles</li>
</ul>

<h3>Configuration Workflow</h3>
<h4>Interactive Canvas Editor</h4>
<ul>
  <li><b>Visual Positioning:</b> Drag-and-drop placeholder rectangles to position images</li>
  <li><b>Magnetic Helpers:</b> Snap-to-grid and alignment guides for precise positioning</li>
  <li><b>Properties Panel:</b> Fine-tune settings for selected images with numeric inputs</li>
  <li><b>Real-time Preview:</b> See exactly how your mosaic will look with color-coded placeholders</li>
  <li><b>Dynamic Management:</b> Add, remove, and duplicate image configurations with visual feedback</li>
  <li><b>Grid System:</b> Optional grid overlay with configurable snap-to-grid functionality</li>
</ul>

<h3>Error Handling & Validation</h3>
<ul>
  <li><b>Input Validation:</b> Comprehensive validation of image arrays and configurations</li>
  <li><b>Bounds Checking:</b> Automatic handling of out-of-bounds coordinates and indices</li>
  <li><b>Transformation Validation:</b> Safe handling of invalid resize and rotation parameters</li>
  <li><b>Canvas Validation:</b> Ensures valid canvas dimensions and background colors</li>
  <li><b>Warning System:</b> Non-fatal issues reported without stopping execution</li>
</ul>

<h3>Example Configurations</h3>
<h4>Photo Collage</h4>
<ul>
  <li>Canvas: 1200x800 pixels, white background</li>
  <li>Image 0: Resize to 300x200, position at (50, 50)</li>
  <li>Image 1: Keep original size, rotate 15°, position at (400, 100)</li>
  <li>Image 2: Resize to 250x250, position at (700, 300)</li>
</ul>

<h4>Dashboard Layout</h4>
<ul>
  <li>Canvas: 1920x1080 pixels, dark background</li>
  <li>Header image: Full width resize, position at (0, 0)</li>
  <li>Sidebar: Fixed height, position at (0, 100)</li>
  <li>Main content: Scaled, position at (300, 100)</li>
</ul>
</script>