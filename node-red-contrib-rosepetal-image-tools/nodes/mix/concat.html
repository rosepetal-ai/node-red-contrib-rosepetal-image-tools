<!-- nodes/rosepetal-concat/concat.html -->

<script type="text/javascript">
    RED.nodes.registerType('concat',{
      category:'RP Image',
      color:'#DDA0DD',
      icon:'font-awesome/fa-th-large',
      defaults:{
        name:{value:""},
        inputPath:{value:"payload"}, inputPathType:{value:"msg"},
        outputPath:{value:"payload"},outputPathType:{value:"msg"},
        outputFormat:{value:"raw"},
        outputQuality:{value:90},
        // Debug configuration
        debugEnabled:{value:false},
        debugWidth:{value:200},
        debugWidthType:{value:"num"},
        direction:{value:"right"},            // right|left|down|up
        strategy :{value:"pad-start"},        // pad-start|pad-end|pad-both|resize
        padColor :{value:"#000000"}
      },
      inputs:1,outputs:1,
      label:function(){return this.name||"concat";},
      oneditprepare:function(){
        /* path typedInputs */
        $("#node-input-inputPath").typedInput({
          default:'msg',types:['msg','flow','global'],
          typeField:"#node-input-inputPathType"});
        $("#node-input-outputPath").typedInput({
          default:'msg',types:['msg','flow','global'],
          typeField:"#node-input-outputPathType"});

        /* colour‑row toggle (only change added) */
        const $strategy=$("#node-input-strategy");
        const $padRow  =$("#pad-colour-row");
        function toggleColour(){ $padRow.toggle($strategy.val()!=="resize"); }
        $strategy.on("change",toggleColour);
        toggleColour();         /* initial state */
        
        function updateQualityVisibility(){
          const format = $("#node-input-outputFormat").val();
          $("#quality-row").toggle(format === "jpg" || format === "webp");
        }
        $("#node-input-outputFormat").on("change", updateQualityVisibility);
        updateQualityVisibility(); // initial state

        // === Debug Display Logic ===
        const debugCheckbox = $('#node-input-debugEnabled');
        const debugWidthRow = $('#debug-width-row');
        
        // Initialize debug width TypedInput
        $("#node-input-debugWidth").typedInput({
            default: 'num',
            types: ['num', 'msg', 'flow', 'global'],
            typeField: "#node-input-debugWidthType"
        });
        
        // Function to toggle debug width visibility
        function updateDebugWidthVisibility() {
            if (debugCheckbox.is(':checked')) {
                debugWidthRow.show();
            } else {
                debugWidthRow.hide();
            }
        }
        
        // Initialize debug state on node open
        updateDebugWidthVisibility();
        
        // Handle debug checkbox changes
        debugCheckbox.on('change', function() {
            const enabled = this.checked;
            updateDebugWidthVisibility();
            // Store debug state for runtime access
            $('#node-input-debugEnabled').data('debug-enabled', enabled);
        });
      }
    });

    // Debug image display renderer - shared across all image processing nodes
    if (!window.debugImageRendererInitialized) {
        window.debugImageRendererInitialized = true;
        
        (function() {
            var isSubscribed = false;
            
            function subscribeToDebugImages() {
                if (isSubscribed || typeof RED === 'undefined' || !RED.comms) return;
                isSubscribed = true;
                
                RED.comms.subscribe('debug-image', function(event, data) {
                    if (!data || !data.id) return;
                    
                    try {
                        renderDebugImage(data);
                    } catch (err) {
                        console.warn('Debug image render error:', err);
                    }
                });
            }
            
            function renderDebugImage(data) {
                const nodeId = data.id;
                const base64Data = data.data;
                const format = data.format || 'unknown';
                const mimeType = data.mimeType || 'jpeg';
                
                if (!base64Data) {
                    removeDebugImage(nodeId);
                    return;
                }
                
                const nodeElement = document.getElementById(nodeId);
                if (!nodeElement) return;
                
                let debugContainer = document.getElementById('debug-img-container-' + nodeId);
                
                if (!debugContainer) {
                    // Create SVG foreignObject to embed HTML content in SVG
                    debugContainer = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                    debugContainer.id = 'debug-img-container-' + nodeId;
                    debugContainer.setAttribute('x', '70');
                    debugContainer.setAttribute('y', '5');
                    debugContainer.setAttribute('width', '120');
                    debugContainer.setAttribute('height', '120');
                    debugContainer.style.overflow = 'visible';
                    
                    // Create simple image directly inside foreignObject
                    const img = document.createElement('img');
                    img.id = 'debug-img-' + nodeId;
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.display = 'block';
                    img.style.cursor = 'pointer';
                    img.style.maxHeight = '100px';
                    img.style.maxWidth = '100px';
                    
                    img.onclick = function() {
                        removeDebugImage(nodeId);
                    };
                    
                    debugContainer.appendChild(img);
                    nodeElement.appendChild(debugContainer);
                }
                
                const img = document.getElementById('debug-img-' + nodeId);
                
                if (img) {
                    img.src = `data:image/${mimeType};base64,${base64Data}`;
                    img.title = 'Debug image (click to hide)';
                }
            }
            
            function removeDebugImage(nodeId) {
                const debugContainer = document.getElementById('debug-img-container-' + nodeId);
                if (debugContainer) {
                    debugContainer.remove();
                }
            }
            
            function initializeWhenReady() {
                if (typeof RED !== 'undefined' && RED.comms) {
                    subscribeToDebugImages();
                    
                    // Clean up orphaned debug images periodically
                    setInterval(function() {
                        const debugContainers = document.querySelectorAll('[id^="debug-img-container-"]');
                        debugContainers.forEach(container => {
                            const nodeId = container.id.replace('debug-img-container-', '');
                            const nodeElement = document.getElementById(nodeId);
                            if (!nodeElement) {
                                container.remove();
                            }
                        });
                    }, 5000);
                } else {
                    setTimeout(initializeWhenReady, 100);
                }
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeWhenReady);
            } else {
                initializeWhenReady();
            }
        })();
    }
  </script>

  <script type="text/x-red" data-template-name="concat">
    <div class="form-row">
      <label><i class="fa fa-sign-in"></i> Input</label>
      <input type="text" id="node-input-inputPath" style="width:70%;">
      <input type="hidden" id="node-input-inputPathType">
    </div>
    <div class="form-row">
      <label><i class="fa fa-sign-out"></i> Output</label>
      <input type="text" id="node-input-outputPath" style="width:70%;">
      <input type="hidden" id="node-input-outputPathType">
    </div>
    <div class="form-row">
      <label for="node-input-outputFormat"><i class="fa fa-file-image-o"></i> Output Format</label>
      <select id="node-input-outputFormat" style="width: 200px;">
        <option value="raw">Raw (fastest)</option>
        <option value="jpg">JPEG</option>
        <option value="png">PNG</option>
        <option value="webp">WebP</option>
      </select>
    </div>
    <div class="form-row" id="quality-row">
      <label for="node-input-outputQuality"><i class="fa fa-sliders"></i> Quality</label>
      <input type="number" id="node-input-outputQuality" min="1" max="100" value="90" style="width: 70px;">
      <span style="margin-left: 10px; color: #666;">1-100 (JPG/WebP only)</span>
    </div>
    
    <!-- Debug Configuration -->
    <div class="form-row">
        <label for="node-input-debugEnabled"><i class="fa fa-bug"></i> Debug</label>
        <input type="checkbox" id="node-input-debugEnabled" style="display:inline-block; width:auto; vertical-align:baseline;">
        <label for="node-input-debugEnabled" style="width:auto; margin-left:5px;">Show processed image</label>
    </div>
    <div class="form-row" id="debug-width-row" style="display: none;">
        <label for="node-input-debugWidth"><i class="fa fa-arrows-h"></i> Debug Width</label>
        <input type="text" id="node-input-debugWidth" style="width: 120px;">
        <input type="hidden" id="node-input-debugWidthType">
        <span style="margin-left: 10px; color: #666;">pixels</span>
    </div>
    
    <hr/>
    <div class="form-row">
      <label><i class="fa fa-arrows-h"></i> Direction</label>
      <select id="node-input-direction">
        <option value="right">→ Right</option>
        <option value="left">← Left</option>
        <option value="down">↓ Down</option>
        <option value="up">↑ Up</option>
      </select>
    </div>
    <div class="form-row">
      <label><i class="fa fa-th"></i> Strategy</label>
      <select id="node-input-strategy">
        <option value="pad-start">Pad at start</option>
        <option value="pad-end">Pad at end</option>
        <option value="pad-both">Pad both sides</option>
        <option value="resize">Resize to max</option>
      </select>
    </div>
    <!-- único cambio: id para poder toggle‑ar -->
    <div class="form-row" id="pad-colour-row">
      <label for="node-input-padColor"><i class="fa fa-tint"></i> Pad colour</label>
      <input type="color" id="node-input-padColor" style="width:80px;">
    </div>
  </script>

  <script type="text/x-red" data-help-name="concat">
    <p><b>rosepetal-concat</b> combines multiple images into a single composite image through concatenation. Images can be joined horizontally or vertically with intelligent handling of size differences using padding or scaling strategies.</p>

    <h3>Details</h3>
    <p>This node processes arrays of images and combines them into a seamless composite using high-performance C++ operations. It supports flexible concatenation directions, intelligent sizing strategies, and maintains image quality throughout the process. The node handles both raw pixel data and encoded image files transparently.</p>

    <h3>Properties</h3>
    <dl class="message-properties">
      <dt>Input from <span class="property-type">string</span></dt>
      <dd>Message property path containing the input image array. Supports <code>msg</code>, <code>flow</code>, or <code>global</code> context via TypedInput.</dd>
      
      <dt>Output to <span class="property-type">string</span></dt>
      <dd>Message property path where the concatenated image will be stored. Supports <code>msg</code>, <code>flow</code>, or <code>global</code> context via TypedInput.</dd>
      
      <dt>Output Format <span class="property-type">string</span></dt>
      <dd>Format for the output image: <code>raw</code> (fastest), <code>jpg</code>, <code>png</code>, or <code>webp</code>.</dd>
      
      <dt>Quality <span class="property-type">number</span></dt>
      <dd>Compression quality (1-100) for JPEG and WebP formats. Only visible when JPG or WebP is selected.</dd>
      
      <dt>Direction <span class="property-type">string</span></dt>
      <dd>Concatenation direction: <code>right</code> (→), <code>left</code> (←), <code>down</code> (↓), or <code>up</code> (↑).</dd>
      
      <dt>Strategy <span class="property-type">string</span></dt>
      <dd>Size handling strategy: <code>pad-start</code>, <code>pad-end</code>, <code>pad-both</code>, or <code>resize</code>.</dd>
      
      <dt>Pad Colour <span class="property-type">color</span></dt>
      <dd>Background color for padding areas when using pad strategies. Hidden when resize strategy is selected.</dd>
    </dl>

    <h3>Inputs</h3>
    <p>The input should be an array of image objects in the standard format:</p>
    <pre>{
  data: Buffer,        // Raw pixel data or encoded file buffer
  width: number,       // Image width in pixels
  height: number,      // Image height in pixels
  channels: number,    // Channel count (1=grayscale, 3=RGB, 4=RGBA)
  colorSpace: string,  // "GRAY", "RGB", "RGBA", "BGR", "BGRA"
  dtype: string        // "uint8", "uint16", "float32"
}</pre>
    <p>File buffers (JPEG, PNG, WebP, BMP) are automatically detected and decoded.</p>

    <h3>Outputs</h3>
    <p>Produces a single concatenated image in the specified format:</p>
    <ul>
      <li><b>Raw format:</b> Complete image object with pixel data and metadata</li>
      <li><b>Encoded formats (JPG/PNG/WebP):</b> File buffer ready for storage or transmission</li>
    </ul>
    <p>Output dimensions depend on input images and concatenation direction. Width/height are calculated automatically based on the combined images.</p>

    <h3>Concatenation Strategies</h3>
    <h4>Padding Strategies</h4>
    <ul>
      <li><b>Pad Start:</b> Adds padding before smaller images (top for horizontal, left for vertical)</li>
      <li><b>Pad End:</b> Adds padding after smaller images (bottom for horizontal, right for vertical)</li>
      <li><b>Pad Both:</b> Centers smaller images with equal padding on both sides</li>
    </ul>
    <h4>Resize Strategy</h4>
    <ul>
      <li><b>Resize:</b> Scales all images to match the largest dimension, eliminating gaps entirely</li>
    </ul>

    <h3>Direction Behavior</h3>
    <ul>
      <li><b>Right (→):</b> Images placed left-to-right, heights normalized</li>
      <li><b>Left (←):</b> Images placed right-to-left, heights normalized</li>
      <li><b>Down (↓):</b> Images stacked top-to-bottom, widths normalized</li>
      <li><b>Up (↑):</b> Images stacked bottom-to-top, widths normalized</li>
    </ul>

    <h3>Examples</h3>
    <h4>Horizontal Photo Strip</h4>
    <p>Create a horizontal photo strip from portrait images:</p>
    <ul>
      <li>Direction: Right (→)</li>
      <li>Strategy: Pad Both</li>
      <li>Pad Color: White (#FFFFFF)</li>
    </ul>

    <h4>Vertical Timeline</h4>
    <p>Stack images vertically for a timeline view:</p>
    <ul>
      <li>Direction: Down (↓)</li>
      <li>Strategy: Resize</li>
      <li>Output: PNG for high quality</li>
    </ul>

    <h4>Dynamic Context Usage</h4>
    <p>Use flow context for batch processing multiple image sets:</p>
    <ul>
      <li>Input from: flow.imageArray</li>
      <li>Output to: flow.concatenated</li>
    </ul>

    <h3>Node Interactions</h3>
    <ul>
      <li><b>Upstream:</b> Works with <code>array-in</code>, <code>image-in</code>, or any nodes producing image arrays</li>
      <li><b>Downstream:</b> Connect to <code>array-out</code>, file writers, or further processing nodes</li>
      <li><b>Chaining:</b> Can be chained with other mix nodes for complex compositions</li>
      <li><b>Flow Integration:</b> Supports flow and global context for cross-node data sharing</li>
    </ul>

    <h3>Output Formats</h3>
    <ul>
      <li><b>Raw (fastest):</b> Uncompressed pixel data, ideal for further processing</li>
      <li><b>JPEG:</b> Lossy compression, smaller files, quality parameter controls compression level</li>
      <li><b>PNG:</b> Lossless compression, preserves transparency, larger files</li>
      <li><b>WebP:</b> Modern format with superior compression, quality parameter available</li>
    </ul>

    <h3>Error Handling</h3>
    <ul>
      <li><b>Input Validation:</b> Comprehensive validation of image structure and array format</li>
      <li><b>Size Compatibility:</b> Automatic handling of different image dimensions</li>
      <li><b>Memory Management:</b> Efficient memory usage with automatic cleanup</li>
      <li><b>Format Support:</b> Graceful handling of mixed input formats</li>
      <li><b>Warning System:</b> Uses <code>node.warn()</code> for non-fatal issues without stopping flow</li>
    </ul>

    <h3>Performance</h3>
    <ul>
      <li><b>C++ Backend:</b> High-performance OpenCV-based processing with optimized build flags</li>
      <li><b>Zero-Copy Operations:</b> Minimal memory allocation and copying for maximum efficiency</li>
      <li><b>Parallel Processing:</b> Array operations processed in parallel using Promise.all()</li>
      <li><b>Status Timing:</b> Real-time performance metrics displayed as <code>conv | task | enc</code> (conversion, processing, encoding)</li>
      <li><b>Memory Optimization:</b> Automatic memory management and garbage collection</li>
      <li><b>Build Optimization:</b> Compiled with <code>-O3</code>, <code>-march=native</code>, <code>-ffast-math</code> flags</li>
    </ul>
  </script>