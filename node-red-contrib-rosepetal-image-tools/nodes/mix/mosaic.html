<!-- ───────── nodes/mix/mosaic.html ────────────── -->

<!-- 1 ▸ Runtime registration -->
<script type="text/javascript">
  RED.nodes.registerType('mosaic',{
  
    category:'RP Image',
    color   :'#DDA0DD',
    icon    :'font-awesome/fa-th',
  
    defaults:{
      name:{value:""},
      inputPath:{value:"payload"},   inputPathType:{value:"msg"},
      outputPath:{value:"payload"},  outputPathType:{value:"msg"},
      outputFormat:{value:"raw"},
      outputQuality:{value:90},
      pngOptimize:{value:false},
      // Debug configuration
      debugEnabled:{value:false},
        debugWidth:{value:200},
        debugWidthType:{value:"num"},
  
      canvasWidth:{value:"800"},   canvasWidthType:{value:"num"},
      canvasHeight:{value:"600"},  canvasHeightType:{value:"num"},
      backgroundColor:{value:"#000000"},
      coordNorm:{value:false},
      
      positions:{value:[]}  // Array of {arrayIndex, x, y} objects
    },
  
    inputs:1, outputs:1,
    label:function(){ return this.name || "mosaic"; },
  
    /* ---------------- oneditprepare ---------------- */
    oneditprepare:function(){
      const node = this;
  
      /* Standard I/O typedInputs */
      $("#node-input-inputPath").typedInput({
        default:'msg',types:['msg','flow','global'],
        typeField:"#node-input-inputPathType"
      });
      $("#node-input-outputPath").typedInput({
        default:'msg',types:['msg','flow','global'],
        typeField:"#node-input-outputPathType"
      });
  
      /* Canvas dimension typedInputs */
      $("#node-input-canvasWidth").typedInput({
        default:'num',
        types:['num','msg','flow','global'],
        typeField:"#node-input-canvasWidthType"
      });
      $("#node-input-canvasHeight").typedInput({
        default:'num',
        types:['num','msg','flow','global'],
        typeField:"#node-input-canvasHeightType"
      });
  
      /* Coordinate normalization toggle */
      function updateCoordTips(){
        const on = $("#node-input-coordNorm").prop("checked");
        $("#norm-enabled").toggle( on );
        $("#norm-disabled").toggle(!on );
      }
      $("#node-input-coordNorm").on("change", updateCoordTips);
      updateCoordTips();
  
      /* Dynamic position mapping table */
      function renderPositionTable() {
        const container = $("#position-container");
        container.empty();
        
        const table = $('<table id="position-table" style="width:100%; border-collapse: collapse; margin: 10px 0;">');
        const header = $('<tr style="background-color: #f0f0f0; font-weight: bold;">');
        header.append('<td style="padding: 8px; border: 1px solid #ddd;">Array Index</td>');
        header.append('<td style="padding: 8px; border: 1px solid #ddd;">X Position</td>');
        header.append('<td style="padding: 8px; border: 1px solid #ddd;">Y Position</td>');
        header.append('<td style="padding: 8px; border: 1px solid #ddd;">Actions</td>');
        table.append(header);
        
        node.positions.forEach((pos, index) => {
          const row = $('<tr>');
          row.append(`<td style="padding: 8px; border: 1px solid #ddd;"><input type="number" value="${pos.arrayIndex}" min="0" class="array-index" style="width: 100%;" /></td>`);
          row.append(`<td style="padding: 8px; border: 1px solid #ddd;"><input type="number" value="${pos.x}" class="pos-x" style="width: 100%;" step="any" /></td>`);
          row.append(`<td style="padding: 8px; border: 1px solid #ddd;"><input type="number" value="${pos.y}" class="pos-y" style="width: 100%;" step="any" /></td>`);
          row.append(`<td style="padding: 8px; border: 1px solid #ddd;"><button type="button" class="remove-position" data-index="${index}" style="background: #ff4444; color: white; border: none; padding: 4px 8px; cursor: pointer;">Remove</button></td>`);
          table.append(row);
        });
        
        container.append(table);
        
        // Add new position button
        const addButton = $('<button type="button" id="add-position" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; margin-top: 10px; cursor: pointer;">Add Position</button>');
        container.append(addButton);
      }
      
      // Initialize positions if empty
      if (!node.positions || node.positions.length === 0) {
        node.positions = [{arrayIndex: 0, x: 0, y: 0}];
      }
      
      renderPositionTable();
      
      // Add position handler
      $("#position-container").on("click", "#add-position", function() {
        node.positions.push({arrayIndex: 0, x: 0, y: 0});
        renderPositionTable();
        RED.nodes.dirty(true); // Mark node as dirty
      });
      
      // Remove position handler
      $("#position-container").on("click", ".remove-position", function() {
        const index = $(this).data("index");
        node.positions.splice(index, 1);
        renderPositionTable();
        RED.nodes.dirty(true); // Mark node as dirty
      });
      
      // Update positions when values change and mark node as dirty
      $("#position-container").on("input", "input", function() {
        const row = $(this).closest("tr");
        const index = row.index() - 1; // Subtract 1 for header row
        
        if (index >= 0 && index < node.positions.length) {
          node.positions[index].arrayIndex = parseInt(row.find(".array-index").val()) || 0;
          node.positions[index].x = parseFloat(row.find(".pos-x").val()) || 0;
          node.positions[index].y = parseFloat(row.find(".pos-y").val()) || 0;
          
          // Mark the node as dirty so Node-RED enables deploy
          RED.nodes.dirty(true);
        }
      });
      
      function updateQualityVisibility(){
        const format = $("#node-input-outputFormat").val();
        $("#quality-row").toggle(format === "jpg" || format === "webp");
        $("#png-optimize-row").toggle(format === "png");
      }
      $("#node-input-outputFormat").on("change", updateQualityVisibility);
      updateQualityVisibility(); // initial state

        // === Debug Display Logic ===
        const debugCheckbox = $('#node-input-debugEnabled');
        const debugWidthRow = $('#debug-width-row');
        
        // Initialize debug width TypedInput
        $("#node-input-debugWidth").typedInput({
            default: 'num',
            types: ['num', 'msg', 'flow', 'global'],
            typeField: "#node-input-debugWidthType"
        });
        
        // Function to toggle debug width visibility
        function updateDebugWidthVisibility() {
            if (debugCheckbox.is(':checked')) {
                debugWidthRow.show();
            } else {
                debugWidthRow.hide();
            }
        }
        
        // Initialize debug state on node open
        updateDebugWidthVisibility();
        
        // Handle debug checkbox changes
        debugCheckbox.on('change', function() {
            const enabled = this.checked;
            updateDebugWidthVisibility();
            // Store debug state for runtime access
            $('#node-input-debugEnabled').data('debug-enabled', enabled);
        });
    }
  });

  // Debug image display renderer - shared across all image processing nodes
  if (!window.debugImageRendererInitialized) {
      window.debugImageRendererInitialized = true;
      
      (function() {
          var isSubscribed = false;
          
          function subscribeToDebugImages() {
              if (isSubscribed || typeof RED === 'undefined' || !RED.comms) return;
              isSubscribed = true;
              
              RED.comms.subscribe('debug-image', function(event, data) {
                  if (!data || !data.id) return;
                  
                  try {
                      renderDebugImage(data);
                  } catch (err) {
                      console.warn('Debug image render error:', err);
                  }
              });
          }
          
          function renderDebugImage(data) {
              const nodeId = data.id;
              const base64Data = data.data;
              const format = data.format || 'unknown';
              const mimeType = data.mimeType || 'jpeg';
              
              if (!base64Data) {
                  removeDebugImage(nodeId);
                  return;
              }
              
              const nodeElement = document.getElementById(nodeId);
              if (!nodeElement) return;
              
              let debugContainer = document.getElementById('debug-img-container-' + nodeId);
              
              if (!debugContainer) {
                  // Create SVG foreignObject to embed HTML content in SVG
                  debugContainer = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                  debugContainer.id = 'debug-img-container-' + nodeId;
                  debugContainer.setAttribute('x', '70');
                  debugContainer.setAttribute('y', '5');
                  debugContainer.setAttribute('width', '120');
                  debugContainer.setAttribute('height', '120');
                  debugContainer.style.overflow = 'visible';
                  
                  // Create simple image directly inside foreignObject
                  const img = document.createElement('img');
                  img.id = 'debug-img-' + nodeId;
                  img.style.width = '100%';
                  img.style.height = 'auto';
                  img.style.display = 'block';
                  img.style.cursor = 'pointer';
                  img.style.maxHeight = '100px';
                  img.style.maxWidth = '100px';
                  
                  img.onclick = function() {
                      removeDebugImage(nodeId);
                  };
                  
                  debugContainer.appendChild(img);
                  nodeElement.appendChild(debugContainer);
              }
              
              const img = document.getElementById('debug-img-' + nodeId);
              
              if (img) {
                  img.src = `data:image/${mimeType};base64,${base64Data}`;
                  img.title = 'Debug image (click to hide)';
              }
          }
          
          function removeDebugImage(nodeId) {
              const debugContainer = document.getElementById('debug-img-container-' + nodeId);
              if (debugContainer) {
                  debugContainer.remove();
              }
          }
          
          function initializeWhenReady() {
              if (typeof RED !== 'undefined' && RED.comms) {
                  subscribeToDebugImages();
                  
                  // Clean up orphaned debug images periodically
                  setInterval(function() {
                      const debugContainers = document.querySelectorAll('[id^="debug-img-container-"]');
                      debugContainers.forEach(container => {
                          const nodeId = container.id.replace('debug-img-container-', '');
                          const nodeElement = document.getElementById(nodeId);
                          if (!nodeElement) {
                              container.remove();
                          }
                      });
                  }, 5000);
              } else {
                  setTimeout(initializeWhenReady, 100);
              }
          }
          
          if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', initializeWhenReady);
          } else {
              initializeWhenReady();
          }
      })();
  }
</script>

<!-- 2 ▸ Edit‑dialog template -->
<script type="text/x-red" data-template-name="mosaic">

<!-- Name -->
<div class="form-row">
  <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
  <input type="text" id="node-input-name" placeholder="Name">
</div>

<hr>

<!-- STANDARD I/O SECTION (copied from crop.html) -->
<div class="form-row">
  <label for="node-input-inputPath"><i class="fa fa-sign-in"></i> Input from</label>
  <input type="text" id="node-input-inputPath" style="width: 70%;">
  <input type="hidden" id="node-input-inputPathType">
</div>
<div class="form-row">
  <label for="node-input-outputPath"><i class="fa fa-sign-out"></i> Output to</label>
  <input type="text" id="node-input-outputPath" style="width: 70%;">
  <input type="hidden" id="node-input-outputPathType">
</div>
<div class="form-row">
  <label for="node-input-outputFormat"><i class="fa fa-file-image-o"></i> Output Format</label>
  <select id="node-input-outputFormat" style="width: 200px;">
    <option value="raw">Raw (fastest)</option>
    <option value="jpg">JPEG</option>
    <option value="png">PNG</option>
    <option value="webp">WebP</option>
  </select>
</div>
<div class="form-row" id="quality-row">
  <label for="node-input-outputQuality"><i class="fa fa-sliders"></i> Quality</label>
  <input type="number" id="node-input-outputQuality" min="1" max="100" value="90" style="width: 70px;">
  <span style="margin-left: 10px; color: #666;">1-100 (JPG/WebP only)</span>
</div>
<div class="form-row" id="png-optimize-row" style="display: none;">
  <label for="node-input-pngOptimize"><i class="fa fa-compress"></i> PNG Optimize</label>
  <input type="checkbox" id="node-input-pngOptimize" style="display:inline-block; width:auto; vertical-align:baseline;">
  <label for="node-input-pngOptimize" style="width:auto; margin-left:5px;">Compress PNG (slower, smaller file)</label>
</div>

  <!-- Debug Configuration -->
  <div class="form-row">
    <label for="node-input-debugEnabled"><i class="fa fa-bug"></i> Debug</label>
    <input type="checkbox" id="node-input-debugEnabled" style="display:inline-block; width:auto; vertical-align:baseline;">
    <label for="node-input-debugEnabled" style="width:auto; margin-left:5px;">Show processed image</label>
  </div>
  <div class="form-row" id="debug-width-row" style="display: none;">
    <label for="node-input-debugWidth"><i class="fa fa-arrows-h"></i> Debug Width</label>
    <input type="text" id="node-input-debugWidth" style="width: 120px;">
    <input type="hidden" id="node-input-debugWidthType">
    <span style="margin-left: 10px; color: #666;">pixels</span>
  </div>

<hr>

<!-- CANVAS CONFIGURATION -->
<div class="form-row">
  <label for="node-input-canvasWidth"><i class="fa fa-arrows-h"></i> Canvas Width</label>
  <input type="text" id="node-input-canvasWidth" style="width: 70%;" placeholder="800">
  <input type="hidden" id="node-input-canvasWidthType">
</div>
<div class="form-row">
  <label for="node-input-canvasHeight"><i class="fa fa-arrows-v"></i> Canvas Height</label>
  <input type="text" id="node-input-canvasHeight" style="width: 70%;" placeholder="600">
  <input type="hidden" id="node-input-canvasHeightType">
</div>
<div class="form-row">
  <label for="node-input-backgroundColor"><i class="fa fa-paint-brush"></i> Background Color</label>
  <input type="color" id="node-input-backgroundColor" style="width: 70px; height: 30px;">
</div>

<div class="form-row">
  <label for="node-input-coordNorm"><i class="fa fa-percent"></i> Normalized Coords</label>
  <input type="checkbox" id="node-input-coordNorm" style="width: 20px; height: 20px;">
</div>

<!-- Tips that toggle -->
<div id="norm-enabled" class="form-tips" style="font-size: 0.85em; margin: 4px 0; color: #666;">
  <b>Normalized ON:</b> position values must be between <code>0.0</code> and <code>1.0</code> (fractions of canvas dimensions).
</div>
<div id="norm-disabled" class="form-tips" style="font-size: 0.85em; margin: 4px 0; color: #666;">
  <b>Normalized OFF:</b> position values are absolute pixels from top-left corner.
</div>

<hr>

<!-- POSITION MAPPING TABLE -->
<div class="form-row">
  <label style="width: 100%; margin-bottom: 10px;"><i class="fa fa-th"></i> Image Positions</label>
  <div id="position-container" style="width: 100%;"></div>
</div>

<div class="form-tips">
  <b>Instructions:</b>
  <ul>
    <li><b>Array Index:</b> Which image from the input array to place (0 = first image, 1 = second, etc.)</li>
    <li><b>X, Y Position:</b> Top-left corner coordinates on the canvas</li>
    <li><b>Multiple Positions:</b> Same image can be placed multiple times at different positions</li>
    <li><b>Dynamic Configuration:</b> Use Add/Remove buttons to manage position mappings</li>
  </ul>
</div>
</script>

<!-- 3 ▸ Help panel -->
<script type="text/x-red" data-help-name="mosaic">
<p><b>rosepetal-mosaic</b> creates a composite image by placing multiple images from an input array onto a canvas at specified positions. This node enables precise control over image positioning, supports normalized coordinates, and offers flexible canvas configuration for creating complex image layouts.</p>

<h3>Details</h3>
<p>This node processes arrays of images and places them onto a customizable canvas using high-performance C++ operations. It supports both absolute pixel coordinates and normalized coordinates (0.0-1.0), dynamic canvas sizing, and flexible positioning controls. The node handles both raw pixel data and encoded image files transparently, making it ideal for creating collages, dashboards, and composite layouts.</p>

<h3>Properties</h3>
<dl class="message-properties">
  <dt>Input from <span class="property-type">string</span></dt>
  <dd>Message property path containing the input image array. Supports <code>msg</code>, <code>flow</code>, or <code>global</code> context via TypedInput.</dd>
  
  <dt>Output to <span class="property-type">string</span></dt>
  <dd>Message property path where the mosaic image will be stored. Supports <code>msg</code>, <code>flow</code>, or <code>global</code> context via TypedInput.</dd>
  
  <dt>Output Format <span class="property-type">string</span></dt>
  <dd>Format for the output image: <code>raw</code> (fastest), <code>jpg</code>, <code>png</code>, or <code>webp</code>.</dd>
  
  <dt>Quality <span class="property-type">number</span></dt>
  <dd>Compression quality (1-100) for JPEG and WebP formats. Only visible when JPG or WebP is selected.</dd>
  
  <dt>Canvas Width <span class="property-type">number|string</span></dt>
  <dd>Width of the output canvas in pixels. Supports dynamic values from <code>msg</code>, <code>flow</code>, or <code>global</code> context via TypedInput.</dd>
  
  <dt>Canvas Height <span class="property-type">number|string</span></dt>
  <dd>Height of the output canvas in pixels. Supports dynamic values from <code>msg</code>, <code>flow</code>, or <code>global</code> context via TypedInput.</dd>
  
  <dt>Background Color <span class="property-type">color</span></dt>
  <dd>Canvas background color in hex format (e.g., #000000). Images are placed on top of this background.</dd>
  
  <dt>Normalized Coords <span class="property-type">boolean</span></dt>
  <dd>When enabled, position coordinates use normalized values (0.0-1.0) as fractions of canvas dimensions. When disabled, coordinates are absolute pixels.</dd>
  
  <dt>Image Positions <span class="property-type">array</span></dt>
  <dd>Dynamic table of position mappings. Each row specifies: Array Index (which input image), X Position, Y Position. Same image can be placed multiple times.</dd>
</dl>

<h3>Inputs</h3>
<p>The input should be an array of image objects in the standard format:</p>
<pre>{
  data: Buffer,        // Raw pixel data or encoded file buffer
  width: number,       // Image width in pixels
  height: number,      // Image height in pixels
  channels: number,    // Channel count (1=grayscale, 3=RGB, 4=RGBA)
  colorSpace: string,  // "GRAY", "RGB", "RGBA", "BGR", "BGRA"
  dtype: string        // "uint8", "uint16", "float32"
}</pre>
<p>File buffers (JPEG, PNG, WebP, BMP) are automatically detected and decoded.</p>

<h3>Outputs</h3>
<p>Produces a single composite mosaic image in the specified format:</p>
<ul>
  <li><b>Raw format:</b> Complete image object with pixel data and metadata</li>
  <li><b>Encoded formats (JPG/PNG/WebP):</b> File buffer ready for storage or transmission</li>
</ul>
<p>Output dimensions match the configured canvas size. Images are placed at their specified positions, potentially overlapping if coordinates overlap.</p>

<h3>Position Mapping System</h3>
<h4>Array Index</h4>
<ul>
  <li><b>Zero-based indexing:</b> 0 = first image, 1 = second image, etc.</li>
  <li><b>Multiple placement:</b> Same image can be referenced multiple times for duplication</li>
  <li><b>Out-of-bounds handling:</b> Invalid indices are gracefully ignored with warnings</li>
</ul>

<h4>Coordinate Systems</h4>
<ul>
  <li><b>Absolute pixels (Normalized OFF):</b> Direct pixel coordinates from top-left corner (0,0)</li>
  <li><b>Normalized coordinates (Normalized ON):</b> Values 0.0-1.0 as fractions of canvas dimensions</li>
  <li><b>Position reference:</b> All coordinates specify the top-left corner of placed images</li>
</ul>

<h4>Dynamic Configuration</h4>
<ul>
  <li><b>Add/Remove buttons:</b> Dynamically manage position mappings in the editor</li>
  <li><b>Real-time validation:</b> Invalid values are automatically corrected</li>
  <li><b>Persistent configuration:</b> Position mappings are saved with the flow</li>
</ul>

<h3>Examples</h3>
<h4>Photo Collage</h4>
<p>Create a photo collage with normalized positioning:</p>
<ul>
  <li>Canvas: 1200x800 pixels</li>
  <li>Normalized Coords: ON</li>
  <li>Positions: (0, 0.1, 0.1), (1, 0.6, 0.1), (2, 0.1, 0.6), (3, 0.6, 0.6)</li>
  <li>Background: White (#FFFFFF)</li>
</ul>

<h4>Dashboard Layout</h4>
<p>Create a dashboard with absolute positioning:</p>
<ul>
  <li>Canvas: 1920x1080 pixels</li>
  <li>Normalized Coords: OFF</li>
  <li>Header image at (0, 0), sidebar at (0, 100), main content at (300, 100)</li>
  <li>Background: Dark gray (#333333)</li>
</ul>

<h4>Dynamic Canvas from Context</h4>
<p>Use flow context for dynamic sizing:</p>
<ul>
  <li>Canvas Width: flow.screenWidth</li>
  <li>Canvas Height: flow.screenHeight</li>
  <li>Input from: flow.thumbnails</li>
  <li>Responsive positioning based on screen dimensions</li>
</ul>

<h3>Mosaic Patterns</h3>
<h4>Grid Layouts</h4>
<ul>
  <li><b>Regular Grid:</b> Use normalized coordinates with calculated spacing (e.g., 0.25, 0.5, 0.75)</li>
  <li><b>Asymmetric Grid:</b> Mix different image sizes with custom positioning</li>
  <li><b>Overlapping Grid:</b> Create layered effects with overlapping positions</li>
</ul>

<h4>Artistic Arrangements</h4>
<ul>
  <li><b>Scattered Layout:</b> Random positioning for organic arrangements</li>
  <li><b>Circular Pattern:</b> Calculate positions around a center point</li>
  <li><b>Layered Composition:</b> Z-order determined by position mapping sequence</li>
</ul>

<h3>Node Interactions</h3>
<ul>
  <li><b>Upstream:</b> Works with <code>array-in</code>, <code>image-in</code>, or any nodes producing image arrays</li>
  <li><b>Downstream:</b> Connect to <code>array-out</code>, file writers, or display nodes</li>
  <li><b>Chaining:</b> Can be combined with <code>concat</code> and other processing nodes</li>
  <li><b>Context Integration:</b> Supports dynamic canvas sizing and positioning via context</li>
  <li><b>Flow Coordination:</b> Use with inject nodes for automated mosaic generation</li>
</ul>

<h3>Output Formats</h3>
<ul>
  <li><b>Raw (fastest):</b> Uncompressed pixel data, ideal for further processing or chaining</li>
  <li><b>JPEG:</b> Lossy compression with quality control, smaller files for web display</li>
  <li><b>PNG:</b> Lossless compression, preserves transparency, larger files</li>
  <li><b>WebP:</b> Modern format with superior compression and quality control</li>
</ul>

<h3>Error Handling</h3>
<ul>
  <li><b>Input Validation:</b> Comprehensive validation of image array structure and position mappings</li>
  <li><b>Bounds Checking:</b> Automatic handling of out-of-bounds coordinates and array indices</li>
  <li><b>Canvas Validation:</b> Ensures valid canvas dimensions with minimum size constraints</li>
  <li><b>Memory Management:</b> Efficient memory usage with automatic cleanup and garbage collection</li>
  <li><b>Position Validation:</b> Validates coordinate ranges for both absolute and normalized modes</li>
  <li><b>Warning System:</b> Uses <code>node.warn()</code> for non-fatal issues without stopping flow execution</li>
</ul>

<h3>Performance</h3>
<ul>
  <li><b>C++ Backend:</b> High-performance OpenCV-based processing with optimized build flags</li>
  <li><b>Zero-Copy Operations:</b> Minimal memory allocation and copying for maximum efficiency</li>
  <li><b>Parallel Processing:</b> Image placement operations processed in parallel using Promise.all()</li>
  <li><b>Canvas Optimization:</b> Efficient canvas initialization and background rendering</li>
  <li><b>Memory Pooling:</b> Reuses memory buffers across operations to reduce allocation overhead</li>
  <li><b>Build Optimization:</b> Compiled with <code>-O3</code>, <code>-march=native</code>, <code>-ffast-math</code> flags</li>
  <li><b>Position Caching:</b> Optimized coordinate calculations for repeated positioning operations</li>
</ul>
</script>