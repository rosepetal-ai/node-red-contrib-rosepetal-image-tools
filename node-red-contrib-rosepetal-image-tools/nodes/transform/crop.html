<!-- ───────── nodes/rosepetal-crop/crop.html (revised) ────────────── -->

<!-- 1 ▸ Runtime registration -->
<script type="text/javascript">
  RED.nodes.registerType('crop',{
  
    category:'RP Image',
    color   :'#DDA0DD',
    icon    :'font-awesome/fa-crop',
  
    defaults:{
      name:{value:""},
      inputPath:{value:"payload"},   inputPathType:{value:"msg"},
      outputPath:{value:"payload"},  outputPathType:{value:"msg"},
      outputFormat:{value:"raw"},
      outputQuality:{value:90},
      // Debug configuration
      debugEnabled:{value:false},
  
      coordNorm:{value:true},      /* ⇄ pixels / 0–1 */
  
      /* coords */
      cropX:{value:"0"},   cropXType:{value:"num"},
      cropY:{value:"0"},   cropYType:{value:"num"},
      width:{value:"1"},   widthType:{value:"num"},
      height:{value:"1"},   heightType:{value:"num"}
    },
  
    inputs:1, outputs:1,
    label:function(){ return this.name || "crop"; },
  
    /* ---------------- oneditprepare ---------------- */
    oneditprepare:function(){
  
      /* I/O typedInputs */
      $("#node-input-inputPath").typedInput({
        default:'msg',types:['msg','flow','global'],
        typeField:"#node-input-inputPathType"
      });
      $("#node-input-outputPath").typedInput({
        default:'msg',types:['msg','flow','global'],
        typeField:"#node-input-outputPathType"
      });
  
      /* coordinate typedInputs */
      ["cropX","cropY","width","height"].forEach(id=>{
        $("#node-input-"+id).typedInput({
          default:'num',
          types:['num','msg','flow','global'],
          typeField:"#node-input-"+id+"Type"
        });
      });
  
      /* normalised toggle → show/hide help blocks */
      function updateTips(){
        const on = $("#node-input-coordNorm").prop("checked");
        $("#norm-enabled").toggle( on );
        $("#norm-disabled").toggle(!on );
      }
      $("#node-input-coordNorm").on("change",updateTips);
      updateTips();          // initial state

      /* output format → show/hide quality */
      function updateQualityVisibility(){
        const format = $("#node-input-outputFormat").val();
        $("#quality-row").toggle(format === "jpg" || format === "webp");
      }
      $("#node-input-outputFormat").on("change", updateQualityVisibility);
      updateQualityVisibility(); // initial state

      // === Debug Display Logic ===
      const debugCheckbox = $('#node-input-debugEnabled');
      
      // Initialize debug state on node open
      if (debugCheckbox.is(':checked')) {
          this.debugDisplay = true;
      }
      
      // Handle debug checkbox changes
      debugCheckbox.on('change', function() {
          const enabled = this.checked;
          // Store debug state for runtime access
          $('#node-input-debugEnabled').data('debug-enabled', enabled);
      });
    }
  });

  // Debug image display renderer - shared across all image processing nodes
  if (!window.debugImageRendererInitialized) {
      window.debugImageRendererInitialized = true;
      
      (function() {
          var isSubscribed = false;
          
          function subscribeToDebugImages() {
              if (isSubscribed || typeof RED === 'undefined' || !RED.comms) return;
              isSubscribed = true;
              
              RED.comms.subscribe('debug-image', function(event, data) {
                  if (!data || !data.id) return;
                  
                  try {
                      renderDebugImage(data);
                  } catch (err) {
                      console.warn('Debug image render error:', err);
                  }
              });
          }
          
          function renderDebugImage(data) {
              const nodeId = data.id;
              const base64Data = data.data;
              const format = data.format || 'unknown';
              const mimeType = data.mimeType || 'jpeg';
              
              if (!base64Data) {
                  removeDebugImage(nodeId);
                  return;
              }
              
              const nodeElement = document.getElementById(nodeId);
              if (!nodeElement) return;
              
              let debugContainer = document.getElementById('debug-img-container-' + nodeId);
              
              if (!debugContainer) {
                  // Create SVG foreignObject to embed HTML content in SVG
                  debugContainer = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                  debugContainer.id = 'debug-img-container-' + nodeId;
                  debugContainer.setAttribute('x', '70');
                  debugContainer.setAttribute('y', '5');
                  debugContainer.setAttribute('width', '120');
                  debugContainer.setAttribute('height', '120');
                  debugContainer.style.overflow = 'visible';
                  
                  // Create simple image directly inside foreignObject
                  const img = document.createElement('img');
                  img.id = 'debug-img-' + nodeId;
                  img.style.width = '100%';
                  img.style.height = 'auto';
                  img.style.display = 'block';
                  img.style.cursor = 'pointer';
                  img.style.maxHeight = '100px';
                  img.style.maxWidth = '100px';
                  
                  img.onclick = function() {
                      removeDebugImage(nodeId);
                  };
                  
                  debugContainer.appendChild(img);
                  nodeElement.appendChild(debugContainer);
              }
              
              const img = document.getElementById('debug-img-' + nodeId);
              
              if (img) {
                  img.src = `data:image/${mimeType};base64,${base64Data}`;
                  img.title = 'Debug image (click to hide)';
              }
          }
          
          function removeDebugImage(nodeId) {
              const debugContainer = document.getElementById('debug-img-container-' + nodeId);
              if (debugContainer) {
                  debugContainer.remove();
              }
          }
          
          function initializeWhenReady() {
              if (typeof RED !== 'undefined' && RED.comms) {
                  subscribeToDebugImages();
                  
                  // Clean up orphaned debug images periodically
                  setInterval(function() {
                      const debugContainers = document.querySelectorAll('[id^="debug-img-container-"]');
                      debugContainers.forEach(container => {
                          const nodeId = container.id.replace('debug-img-container-', '');
                          const nodeElement = document.getElementById(nodeId);
                          if (!nodeElement) {
                              container.remove();
                          }
                      });
                  }, 5000);
              } else {
                  setTimeout(initializeWhenReady, 100);
              }
          }
          
          if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', initializeWhenReady);
          } else {
              initializeWhenReady();
          }
      })();
  }
  </script>
  
  <!-- 2 ▸ Edit‑dialog template -->
  <script type="text/x-red" data-template-name="crop">
  
  <!-- Name -->
  <div class="form-row">
    <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  
  <hr>
  
  <!-- STANDARD I/O SECTION (same as all other nodes) -->
  <div class="form-row">
    <label for="node-input-inputPath"><i class="fa fa-sign-in"></i> Input from</label>
    <input type="text" id="node-input-inputPath" style="width: 70%;">
    <input type="hidden" id="node-input-inputPathType">
  </div>
  <div class="form-row">
    <label for="node-input-outputPath"><i class="fa fa-sign-out"></i> Output to</label>
    <input type="text" id="node-input-outputPath" style="width: 70%;">
    <input type="hidden" id="node-input-outputPathType">
  </div>
  <div class="form-row">
    <label for="node-input-outputFormat"><i class="fa fa-file-image-o"></i> Output Format</label>
    <select id="node-input-outputFormat" style="width: 200px;">
      <option value="raw">Raw (fastest)</option>
      <option value="jpg">JPEG</option>
      <option value="png">PNG</option>
      <option value="webp">WebP</option>
    </select>
  </div>
  <div class="form-row" id="quality-row">
    <label for="node-input-outputQuality"><i class="fa fa-sliders"></i> Quality</label>
    <input type="number" id="node-input-outputQuality" min="1" max="100" value="90" style="width: 70px;">
    <span style="margin-left: 10px; color: #666;">1-100 (JPG/WebP only)</span>
  </div>
  
  <!-- Debug Configuration -->
  <div class="form-row">
    <label for="node-input-debugEnabled"><i class="fa fa-bug"></i> Debug</label>
    <input type="checkbox" id="node-input-debugEnabled" style="display:inline-block; width:auto; vertical-align:baseline;">
    <label for="node-input-debugEnabled" style="width:auto; margin-left:5px;">Show processed image</label>
  </div>
  
  <hr>
  
  <!-- CROP-SPECIFIC SECTION -->
  <div class="form-row">
    <label for="node-input-coordNorm"><i class="fa fa-percent"></i> Normalised</label>
    <input type="checkbox" id="node-input-coordNorm" style="width: 20px; height: 20px;">
  </div>
  
  <!-- Tips that toggle -->
  <div id="norm-enabled" class="form-tips" style="font-size: 0.85em; margin: 4px 0; color: #666;">
    <b>Normalised ON:</b> values must be between <code>0.0</code> and <code>1.0</code> (fractions of image dimensions).
  </div>
  <div id="norm-disabled" class="form-tips" style="font-size: 0.85em; margin: 4px 0; color: #666;">
    <b>Normalised OFF:</b> values are absolute pixels from top-left corner.
  </div>

  <div class="form-row">
    <label for="node-input-cropX"><i class="fa fa-arrows-h"></i> X Position</label>
    <input type="text" id="node-input-cropX" style="width: 70%;" placeholder="0">
    <input type="hidden" id="node-input-cropXType">
  </div>
  <div class="form-row">
    <label for="node-input-cropY"><i class="fa fa-arrows-v"></i> Y Position</label>
    <input type="text" id="node-input-cropY" style="width: 70%;" placeholder="0">
    <input type="hidden" id="node-input-cropYType">
  </div>
  <div class="form-row">
    <label for="node-input-width"><i class="fa fa-arrows-h"></i> Width</label>
    <input type="text" id="node-input-width" style="width: 70%;" placeholder="100">
    <input type="hidden" id="node-input-widthType">
  </div>
  <div class="form-row">
    <label for="node-input-height"><i class="fa fa-arrows-v"></i> Height</label>
    <input type="text" id="node-input-height" style="width: 70%;" placeholder="100">
    <input type="hidden" id="node-input-heightType">
  </div>

  <div class="form-tips">
    <b>Tips:</b>
    <ul>
      <li><b>X, Y:</b> Position of the top-left corner of the crop area.</li>
      <li><b>Width, Height:</b> Dimensions of the crop area.</li>
      <li>All parameters support dynamic values from <code>msg</code>, <code>flow</code>, or <code>global</code> context.</li>
    </ul>
  </div>
  </script>
  
  <!-- 3 ▸ Help panel -->
  <script type="text/x-red" data-help-name="crop">
  <p>Extracts a rectangular region from images using flexible coordinate systems and dynamic value sources.</p>
  
  <h3>Details</h3>
  <p>This node crops images by extracting a rectangular region defined by X, Y position and width, height dimensions. It supports both normalized coordinates (0-1 relative to image dimensions) and absolute pixel coordinates. All coordinate values can be dynamically sourced from message properties, flow, or global context.</p>
  
  <h3>Properties</h3>
  <dl class="message-properties">
    <dt>Input from <span class="property-type">string</span></dt>
    <dd>The location to read image data from. You can select between <code>msg</code>, <code>flow</code>, or <code>global</code> context. Defaults to <code>msg.payload</code>.</dd>
    <dt>Output to <span class="property-type">string</span></dt>
    <dd>The location where the cropped image will be stored. You can select between <code>msg</code>, <code>flow</code>, or <code>global</code> context. Defaults to <code>msg.payload</code>.</dd>
    <dt>Output Format <span class="property-type">string</span></dt>
    <dd>Choose output format: <code>raw</code> (fastest, standard image object), <code>jpg</code>, <code>png</code>, or <code>webp</code> (encoded file buffers).</dd>
    <dt>Quality <span class="property-type">number</span></dt>
    <dd>Compression quality for JPEG and WebP formats (1-100). Only visible when jpg or webp format is selected. Default: 90.</dd>
    <dt>Normalised <span class="property-type">boolean</span></dt>
    <dd>When enabled, coordinates are normalized (0.0-1.0 as fractions of image dimensions). When disabled, coordinates are absolute pixels.</dd>
    <dt>X Position <span class="property-type">number|string</span></dt>
    <dd>X coordinate of the top-left corner of the crop area. Can be fixed number or dynamic value from msg property, flow, or global context.</dd>
    <dt>Y Position <span class="property-type">number|string</span></dt>
    <dd>Y coordinate of the top-left corner of the crop area. Can be fixed number or dynamic value from msg property, flow, or global context.</dd>
    <dt>Width <span class="property-type">number|string</span></dt>
    <dd>Width of the crop area. Can be fixed number or dynamic value from msg property, flow, or global context.</dd>
    <dt>Height <span class="property-type">number|string</span></dt>
    <dd>Height of the crop area. Can be fixed number or dynamic value from msg property, flow, or global context.</dd>
  </dl>

  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>payload <span class="property-type">object | array</span></dt>
    <dd>Single image object or array of image objects in standard format: <code>{ data: Buffer, width: number, height: number, channels: number, colorSpace: string, dtype: string }</code></dd>
  </dl>

  <h3>Outputs</h3>
  <dl class="message-properties">
    <dt>payload <span class="property-type">object | array | Buffer</span></dt>
    <dd>Cropped image(s). Format depends on Output Format setting: raw image object(s) or encoded file buffer(s).</dd>
  </dl>

  <h3>Coordinate Systems</h3>
  <p><strong>Normalized Coordinates (0.0-1.0):</strong></p>
  <ul>
    <li><strong>Advantages:</strong> Resolution-independent, easy to work with percentages</li>
    <li><strong>Example:</strong> X=0.25, Y=0.25, Width=0.5, Height=0.5 crops the center quarter of any image</li>
    <li><strong>Range:</strong> All values must be between 0.0 and 1.0</li>
  </ul>
  <p><strong>Absolute Pixel Coordinates:</strong></p>
  <ul>
    <li><strong>Advantages:</strong> Precise pixel-level control</li>
    <li><strong>Example:</strong> X=100, Y=50, Width=200, Height=150 crops a 200x150 region starting at pixel (100,50)</li>
    <li><strong>Range:</strong> Values are in pixels from top-left corner</li>
  </ul>

  <h3>Examples</h3>
  <ul>
    <li><strong>Center Crop (Normalized):</strong> X=0.25, Y=0.25, Width=0.5, Height=0.5 → Center quarter of image</li>
    <li><strong>Top-Left Corner (Pixels):</strong> X=0, Y=0, Width=100, Height=100 → 100x100 pixel square from top-left</li>
    <li><strong>Dynamic Crop:</strong> X=msg.cropX, Y=msg.cropY → Use coordinates from message properties</li>
    <li><strong>Face Detection Crop:</strong> Coordinates calculated by face detection → dynamic cropping based on detected faces</li>
  </ul>

  <h3>Node Interactions</h3>
  <p><strong>Input Sources:</strong> Image-in, Array-out, other transform nodes</p>
  <p><strong>Output Destinations:</strong> Other transform nodes, Mix nodes (concat, mosaic), Array-in for collections</p>
  <p><strong>Common Workflows:</strong> Face detection → Crop, Image preprocessing → Crop → Resize, Batch cropping for thumbnails</p>

  <h3>Output Formats</h3>
  <ul>
    <li><strong>Raw:</strong> Standard image object (fastest, for further processing)</li>
    <li><strong>JPEG:</strong> Compressed file buffer with quality setting</li>
    <li><strong>PNG:</strong> Lossless compressed file buffer</li>
    <li><strong>WebP:</strong> Modern compressed format with quality setting</li>
  </ul>

  <h3>Boundary Handling</h3>
  <p>The node automatically handles boundary conditions:</p>
  <ul>
    <li><strong>Out-of-bounds:</strong> Crop area is clipped to image boundaries</li>
    <li><strong>Invalid coordinates:</strong> Negative positions are clamped to 0</li>
    <li><strong>Oversized dimensions:</strong> Width/height automatically limited to available space</li>
  </ul>

  <h3>Error Handling</h3>
  <p>The node validates input data and coordinates, displaying warnings for invalid inputs. Invalid coordinates are clamped to valid ranges. Processing errors are logged and the message is not propagated.</p>

  <h3>Performance</h3>
  <p>Uses optimized C++ backend with OpenCV for high-performance cropping. Node status displays processing time including conversion, processing, and encoding phases. Array inputs are processed in parallel for optimal performance.</p>
  </script>
  