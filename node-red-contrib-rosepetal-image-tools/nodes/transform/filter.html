<script type="text/javascript">
    RED.nodes.registerType('filter', {
        category: 'RP Image',
        color: '#DDA0DD',
        defaults: {
            name: { value: "" },
            // Standard I/O properties (same as other nodes)
            inputPath: { value: "payload" },
            inputPathType: { value: "msg" },
            outputPath: { value: "payload" },
            outputPathType: { value: "msg" },
            outputFormat: { value: "raw" },
            outputQuality: { value: 90 },
            // Debug configuration
            debugEnabled: { value: false },
            debugWidth: { value: 200 },
            debugWidthType: { value: "num" },
            // Filter-specific properties
            filterType: { value: "blur" },
            kernelSize: { value: "3" },
            kernelSizeType: { value: "num" },
            intensity: { value: "1.0" },
            intensityType: { value: "num" }
        },
        inputs: 1,
        outputs: 1,
        icon: "font-awesome/fa-magic",
        label: function() {
            if (this.name) { return this.name; }
            return `filter`;
        },
        oneditprepare: function() {
            // === Standard I/O TypedInput initialization ===
            $("#node-input-inputPath").typedInput({
                default: 'msg',
                types: ['msg', 'flow', 'global'],
                typeField: "#node-input-inputPathType"
            });
            $("#node-input-outputPath").typedInput({
                default: 'msg',
                types: ['msg', 'flow', 'global'],
                typeField: "#node-input-outputPathType"
            });

            // === Filter-specific TypedInput initialization ===
            $("#node-input-kernelSize").typedInput({
                default: 'num',
                types: ['num', 'msg', 'flow', 'global'],
                typeField: "#node-input-kernelSizeType"
            });
            $("#node-input-intensity").typedInput({
                default: 'num',
                types: ['num', 'msg', 'flow', 'global'],
                typeField: "#node-input-intensityType"
            });

            // === Dynamic parameter updates based on filter type ===
            function updateFilterParameters() {
                const filterType = $("#node-input-filterType").val();
                const kernelSizeRow = $("#kernel-size-row");
                const intensityRow = $("#intensity-row");
                const intensityLabel = $("#intensity-label");
                
                // Show/hide and update labels based on filter type
                switch (filterType) {
                    case 'blur':
                        kernelSizeRow.show();
                        intensityRow.show();
                        intensityLabel.text("Intensity");
                        break;
                    case 'sharpen':
                        kernelSizeRow.show();
                        intensityRow.show();
                        intensityLabel.text("Sharpness");
                        break;
                    case 'edge':
                        kernelSizeRow.show();
                        intensityRow.show();
                        intensityLabel.text("Edge Strength");
                        break;
                    case 'emboss':
                        kernelSizeRow.hide();
                        intensityRow.show();
                        intensityLabel.text("Emboss Depth");
                        break;
                    case 'gaussian':
                        kernelSizeRow.show();
                        intensityRow.show();
                        intensityLabel.text("Blur Radius");
                        break;
                    default:
                        kernelSizeRow.show();
                        intensityRow.show();
                        intensityLabel.text("Intensity");
                }
            }

            // Bind filter type change event
            $("#node-input-filterType").on('change', updateFilterParameters);
            
            // Initial parameter update
            updateFilterParameters();
            
            function updateQualityVisibility(){
                const format = $("#node-input-outputFormat").val();
                $("#quality-row").toggle(format === "jpg" || format === "webp");
            }
            $("#node-input-outputFormat").on("change", updateQualityVisibility);
            updateQualityVisibility(); // initial state

        // === Debug Display Logic ===
        const debugCheckbox = $('#node-input-debugEnabled');
        const debugWidthRow = $('#debug-width-row');
        
        // Initialize debug width TypedInput
        $("#node-input-debugWidth").typedInput({
            default: 'num',
            types: ['num', 'msg', 'flow', 'global'],
            typeField: "#node-input-debugWidthType"
        });
        
        // Function to toggle debug width visibility
        function updateDebugWidthVisibility() {
            if (debugCheckbox.is(':checked')) {
                debugWidthRow.show();
            } else {
                debugWidthRow.hide();
            }
        }
        
        // Initialize debug state on node open
        updateDebugWidthVisibility();
        
        // Handle debug checkbox changes
        debugCheckbox.on('change', function() {
            const enabled = this.checked;
            updateDebugWidthVisibility();
            // Store debug state for runtime access
            $('#node-input-debugEnabled').data('debug-enabled', enabled);
        });
        }
    });

    // Debug image display renderer - shared across all image processing nodes
    if (!window.debugImageRendererInitialized) {
        window.debugImageRendererInitialized = true;
        
        (function() {
            var isSubscribed = false;
            
            function subscribeToDebugImages() {
                if (isSubscribed || typeof RED === 'undefined' || !RED.comms) return;
                isSubscribed = true;
                
                RED.comms.subscribe('debug-image', function(event, data) {
                    if (!data || !data.id) return;
                    
                    try {
                        renderDebugImage(data);
                    } catch (err) {
                        console.warn('Debug image render error:', err);
                    }
                });
            }
            
            function renderDebugImage(data) {
                const nodeId = data.id;
                const base64Data = data.data;
                const format = data.format || 'unknown';
                const mimeType = data.mimeType || 'jpeg';
                
                if (!base64Data) {
                    removeDebugImage(nodeId);
                    return;
                }
                
                const nodeElement = document.getElementById(nodeId);
                if (!nodeElement) return;
                
                let debugContainer = document.getElementById('debug-img-container-' + nodeId);
                
                if (!debugContainer) {
                    // Create SVG foreignObject to embed HTML content in SVG
                    debugContainer = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                    debugContainer.id = 'debug-img-container-' + nodeId;
                    debugContainer.setAttribute('x', '70');
                    debugContainer.setAttribute('y', '5');
                    debugContainer.setAttribute('width', '120');
                    debugContainer.setAttribute('height', '120');
                    debugContainer.style.overflow = 'visible';
                    
                    // Create simple image directly inside foreignObject
                    const img = document.createElement('img');
                    img.id = 'debug-img-' + nodeId;
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.display = 'block';
                    img.style.cursor = 'pointer';
                    img.style.maxHeight = '100px';
                    img.style.maxWidth = '100px';
                    
                    img.onclick = function() {
                        removeDebugImage(nodeId);
                    };
                    
                    debugContainer.appendChild(img);
                    nodeElement.appendChild(debugContainer);
                }
                
                const img = document.getElementById('debug-img-' + nodeId);
                
                if (img) {
                    img.src = `data:image/${mimeType};base64,${base64Data}`;
                    img.title = 'Debug image (click to hide)';
                }
            }
            
            function removeDebugImage(nodeId) {
                const debugContainer = document.getElementById('debug-img-container-' + nodeId);
                if (debugContainer) {
                    debugContainer.remove();
                }
            }
            
            function initializeWhenReady() {
                if (typeof RED !== 'undefined' && RED.comms) {
                    subscribeToDebugImages();
                    
                    // Clean up orphaned debug images periodically
                    setInterval(function() {
                        const debugContainers = document.querySelectorAll('[id^="debug-img-container-"]');
                        debugContainers.forEach(container => {
                            const nodeId = container.id.replace('debug-img-container-', '');
                            const nodeElement = document.getElementById(nodeId);
                            if (!nodeElement) {
                                container.remove();
                            }
                        });
                    }, 5000);
                } else {
                    setTimeout(initializeWhenReady, 100);
                }
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeWhenReady);
            } else {
                initializeWhenReady();
            }
        })();
    }
</script>

<script type="text/x-red" data-template-name="filter">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>

    <hr>

    <!-- STANDARD I/O SECTION (same as all other nodes) -->
    <div class="form-row">
        <label for="node-input-inputPath"><i class="fa fa-sign-in"></i> Input from</label>
        <input type="text" id="node-input-inputPath" style="width: 70%;">
        <input type="hidden" id="node-input-inputPathType">
    </div>
    <div class="form-row">
        <label for="node-input-outputPath"><i class="fa fa-sign-out"></i> Output to</label>
        <input type="text" id="node-input-outputPath" style="width: 70%;">
        <input type="hidden" id="node-input-outputPathType">
    </div>
    <div class="form-row">
        <label for="node-input-outputFormat"><i class="fa fa-file-image-o"></i> Output Format</label>
        <select id="node-input-outputFormat" style="width: 200px;">
            <option value="raw">Raw (fastest)</option>
            <option value="jpg">JPEG</option>
            <option value="png">PNG</option>
            <option value="webp">WebP</option>
        </select>
    </div>
    <div class="form-row" id="quality-row">
        <label for="node-input-outputQuality"><i class="fa fa-sliders"></i> Quality</label>
        <input type="number" id="node-input-outputQuality" min="1" max="100" value="90" style="width: 70px;">
        <span style="margin-left: 10px; color: #666;">1-100 (JPG/WebP only)</span>
    </div>
    
    <!-- Debug Configuration -->
    <div class="form-row">
        <label for="node-input-debugEnabled"><i class="fa fa-bug"></i> Debug</label>
        <input type="checkbox" id="node-input-debugEnabled" style="display:inline-block; width:auto; vertical-align:baseline;">
        <label for="node-input-debugEnabled" style="width:auto; margin-left:5px;">Show processed image</label>
    </div>
    <div class="form-row" id="debug-width-row" style="display: none;">
        <label for="node-input-debugWidth"><i class="fa fa-arrows-h"></i> Debug Width</label>
        <input type="text" id="node-input-debugWidth" style="width: 120px;">
        <input type="hidden" id="node-input-debugWidthType">
        <span style="margin-left: 10px; color: #666;">pixels</span>
    </div>

    <hr>

    <!-- FILTER-SPECIFIC SECTION -->
    <div class="form-row">
        <label for="node-input-filterType"><i class="fa fa-magic"></i> Filter Type</label>
        <select id="node-input-filterType" style="width: 70%;">
            <option value="blur">Blur</option>
            <option value="sharpen">Sharpening</option>
            <option value="edge">Edge Detection</option>
            <option value="emboss">Emboss</option>
            <option value="gaussian">Gaussian Blur</option>
        </select>
    </div>

    <div class="form-row" id="kernel-size-row">
        <label for="node-input-kernelSize"><i class="fa fa-th"></i> Kernel Size</label>
        <input type="text" id="node-input-kernelSize" style="width: 70%;" placeholder="3, 5, 7, 9, 11, 13, 15">
        <input type="hidden" id="node-input-kernelSizeType">
    </div>

    <div class="form-row" id="intensity-row">
        <label for="node-input-intensity" id="intensity-label"><i class="fa fa-sliders"></i> Intensity</label>
        <input type="text" id="node-input-intensity" style="width: 70%;" placeholder="0.0 - 2.0">
        <input type="hidden" id="node-input-intensityType">
    </div>

    <div class="form-tips">
        <b>Tips:</b>
        <ul>
            <li><b>Kernel Size:</b> Must be odd (3, 5, 7, etc.). Larger sizes create stronger effects.</li>
            <li><b>Intensity:</b> 0.0 = no effect, 1.0 = normal, 2.0 = maximum effect.</li>
            <li>All parameters support dynamic values from <code>msg</code>, <code>flow</code>, or <code>global</code> context.</li>
        </ul>
    </div>
</script>

<script type="text/x-red" data-help-name="filter">
    <p>The <strong>filter</strong> node applies professional image processing kernels including blur, sharpening, edge detection, emboss, and Gaussian blur effects. It provides configurable parameters and supports both single images and arrays with high-performance C++ backend processing using OpenCV.</p>

    <h3>Details</h3>
    <p>This node implements various convolution-based image processing operations with precise parameter control. Each filter type uses optimized OpenCV algorithms for maximum performance while maintaining image quality. The node supports dynamic parameter adjustment and multiple output formats, making it suitable for both real-time processing and batch operations.</p>

    <h3>Properties</h3>
    <dl class="message-properties">
        <dt>Name <span class="property-type">string</span></dt>
        <dd>Optional display name for the node</dd>
        
        <dt>Input from <span class="property-type">msg | flow | global</span></dt>
        <dd>Source path for image data (default: <code>msg.payload</code>)</dd>
        
        <dt>Output to <span class="property-type">msg | flow | global</span></dt>
        <dd>Destination path for processed image (default: <code>msg.payload</code>)</dd>
        
        <dt>Output Format <span class="property-type">string</span></dt>
        <dd>Image output format: <code>raw</code>, <code>jpg</code>, <code>png</code>, or <code>webp</code></dd>
        
        <dt>Quality <span class="property-type">number</span></dt>
        <dd>Compression quality 1-100 for JPEG and WebP formats</dd>
        
        <dt>Filter Type <span class="property-type">string</span></dt>
        <dd>Processing algorithm: <code>blur</code>, <code>sharpen</code>, <code>edge</code>, <code>emboss</code>, or <code>gaussian</code></dd>
        
        <dt>Kernel Size <span class="property-type">number | msg | flow | global</span></dt>
        <dd>Convolution kernel size (3, 5, 7, 9, 11, 13, 15). Must be odd numbers</dd>
        
        <dt>Intensity <span class="property-type">number | msg | flow | global</span></dt>
        <dd>Effect strength (0.0-2.0). 0.0=no effect, 1.0=normal, 2.0=maximum</dd>
    </dl>

    <h3>Inputs</h3>
    <dl class="message-properties">
        <dt>payload <span class="property-type">object | array</span></dt>
        <dd>Image object(s) in standard format:
            <pre>{
  data: Buffer,        // Raw pixel data or file buffer
  width: number,       // Image width in pixels
  height: number,      // Image height in pixels
  channels: number,    // Channel count (1, 3, 4)
  colorSpace: string,  // "GRAY", "RGB", "RGBA", "BGR", "BGRA"
  dtype: string        // "uint8", "uint16", "float32"
}</pre>
        </dd>
        <dt>filter parameters <span class="property-type">number</span></dt>
        <dd>When parameters use dynamic sources, values are read from specified paths</dd>
    </dl>

    <h3>Outputs</h3>
    <dl class="message-properties">
        <dt>payload <span class="property-type">object | array | Buffer</span></dt>
        <dd>Processed image(s) with filter applied. Format depends on Output Format setting</dd>
        
        <dt>Raw format output</dt>
        <dd>Image object with processed pixel data:
            <pre>{
  data: Buffer,        // Filtered image data
  width: number,       // Unchanged from input
  height: number,      // Unchanged from input
  channels: number,    // Unchanged from input
  colorSpace: string,  // Unchanged from input
  dtype: string        // Unchanged from input
}</pre>
        </dd>
        
        <dt>Encoded format output</dt>
        <dd>Compressed image buffer (JPEG/PNG/WebP) ready for storage or transmission</dd>
    </dl>

    <h3>Filter Types</h3>
    <h4>Blur</h4>
    <ul>
        <li><strong>Algorithm:</strong> Box blur convolution for uniform smoothing</li>
        <li><strong>Use Cases:</strong> Noise reduction, motion blur simulation, general smoothing</li>
        <li><strong>Kernel Size:</strong> 3-15 (larger = more blur)</li>
        <li><strong>Intensity:</strong> 0.0-2.0 (controls blur strength)</li>
    </ul>

    <h4>Sharpening</h4>
    <ul>
        <li><strong>Algorithm:</strong> Unsharp mask technique to enhance edges and details</li>
        <li><strong>Use Cases:</strong> Photo enhancement, detail restoration, edge enhancement</li>
        <li><strong>Kernel Size:</strong> 3-15 (affects sharpening area)</li>
        <li><strong>Intensity:</strong> 0.0-2.0 (controls sharpening strength)</li>
    </ul>

    <h4>Edge Detection</h4>
    <ul>
        <li><strong>Algorithm:</strong> Sobel operator for gradient-based edge detection</li>
        <li><strong>Use Cases:</strong> Object detection, boundary identification, preprocessing for analysis</li>
        <li><strong>Kernel Size:</strong> 3-15 (affects edge sensitivity)</li>
        <li><strong>Intensity:</strong> 0.0-2.0 (controls edge prominence)</li>
    </ul>

    <h4>Emboss</h4>
    <ul>
        <li><strong>Algorithm:</strong> Directional convolution creating 3D embossed appearance</li>
        <li><strong>Use Cases:</strong> Artistic effects, texture enhancement, relief mapping</li>
        <li><strong>Kernel Size:</strong> Fixed 3x3 (parameter hidden in UI)</li>
        <li><strong>Intensity:</strong> 0.0-2.0 (controls emboss depth)</li>
    </ul>

    <h4>Gaussian Blur</h4>
    <ul>
        <li><strong>Algorithm:</strong> Gaussian distribution-based blur for natural smoothing</li>
        <li><strong>Use Cases:</strong> Background blur, depth of field effects, anti-aliasing</li>
        <li><strong>Kernel Size:</strong> 3-15 (affects blur radius)</li>
        <li><strong>Intensity:</strong> 0.0-2.0 (controls sigma value)</li>
    </ul>

    <h3>Parameter Behavior</h3>
    <h4>Kernel Size Constraints</h4>
    <ul>
        <li><strong>Valid Values:</strong> 3, 5, 7, 9, 11, 13, 15 (odd numbers only)</li>
        <li><strong>Automatic Correction:</strong> Even numbers rounded to nearest odd</li>
        <li><strong>Range Limits:</strong> Values <3 set to 3, values >15 set to 15</li>
        <li><strong>Performance Impact:</strong> Larger kernels require more computation</li>
    </ul>

    <h4>Intensity Scaling</h4>
    <ul>
        <li><strong>Range:</strong> 0.0 (no effect) to 2.0 (maximum effect)</li>
        <li><strong>Default:</strong> 1.0 (standard effect strength)</li>
        <li><strong>Clamping:</strong> Values <0.0 set to 0.0, values >2.0 set to 2.0</li>
        <li><strong>Linear Scaling:</strong> Effect strength scales linearly with intensity</li>
    </ul>

    <h4>Dynamic Parameters</h4>
    <ul>
        <li><strong>Runtime Updates:</strong> Parameters can be modified per message</li>
        <li><strong>Type Validation:</strong> Non-numeric values trigger warnings</li>
        <li><strong>Missing Values:</strong> Use node configuration defaults</li>
        <li><strong>Array Processing:</strong> Same parameters applied to all images in array</li>
    </ul>

    <h3>Examples</h3>
    <h4>Photo Enhancement</h4>
    <pre>// Sharpen a photo with moderate strength
{
  filterType: "sharpen",
  kernelSize: 5,
  intensity: 1.2
}</pre>

    <h4>Background Blur</h4>
    <pre>// Create shallow depth of field effect
{
  filterType: "gaussian",
  kernelSize: 9,
  intensity: 1.5
}</pre>

    <h4>Edge Detection</h4>
    <pre>// Detect edges for computer vision preprocessing
{
  filterType: "edge",
  kernelSize: 3,
  intensity: 1.0
}</pre>

    <h4>Dynamic Filter Selection</h4>
    <pre>// Use message properties for adaptive filtering
msg.filterIntensity = 0.8;
msg.blurAmount = 7;
// Configure node: intensity from msg.filterIntensity, kernelSize from msg.blurAmount</pre>

    <h4>Artistic Effects</h4>
    <pre>// Create embossed relief effect
{
  filterType: "emboss",
  intensity: 1.8
}</pre>

    <h3>Node Interactions</h3>
    <h4>Pre-Processing Chain</h4>
    <ul>
        <li><strong>image-in → resize → filter:</strong> Scale then apply effects</li>
        <li><strong>crop → filter → padding:</strong> Extract region, apply effect, add border</li>
        <li><strong>array-select → filter:</strong> Apply effects to selected images</li>
    </ul>

    <h4>Post-Processing Chain</h4>
    <ul>
        <li><strong>filter → filter:</strong> Stack multiple effects (e.g., blur then sharpen)</li>
        <li><strong>filter → concat:</strong> Apply effects then combine images</li>
        <li><strong>filter → array-out:</strong> Process then encode for output</li>
    </ul>

    <h4>Common Workflows</h4>
    <ul>
        <li><strong>Photo Processing:</strong> resize → filter (sharpen) → array-out</li>
        <li><strong>Computer Vision:</strong> filter (edge) → analysis processing</li>
        <li><strong>Creative Effects:</strong> filter (emboss) → filter (blur) → mosaic</li>
        <li><strong>Noise Reduction:</strong> filter (gaussian) → filter (sharpen) → output</li>
    </ul>

    <h3>Output Formats</h3>
    <dl class="message-properties">
        <dt>raw <span class="property-type">object</span></dt>
        <dd>Fastest option. Returns processed image object for further Node-RED processing</dd>
        
        <dt>jpg <span class="property-type">Buffer</span></dt>
        <dd>JPEG-compressed buffer with configurable quality (1-100). Good for photographs</dd>
        
        <dt>png <span class="property-type">Buffer</span></dt>
        <dd>PNG-compressed buffer with lossless compression. Preserves fine details from filtering</dd>
        
        <dt>webp <span class="property-type">Buffer</span></dt>
        <dd>WebP-compressed buffer with configurable quality. Modern format with excellent compression</dd>
    </dl>

    <h3>Error Handling</h3>
    <ul>
        <li><strong>Invalid Input:</strong> Non-image objects trigger warnings and prevent processing</li>
        <li><strong>Parameter Validation:</strong> Invalid kernel sizes or intensities are corrected with warnings</li>
        <li><strong>Missing Properties:</strong> Incomplete image objects are rejected with detailed error messages</li>
        <li><strong>Unsupported Formats:</strong> Incompatible image data types trigger conversion attempts</li>
        <li><strong>Memory Limits:</strong> Large images with large kernels may fail with memory errors</li>
        <li><strong>Dynamic Values:</strong> Missing or invalid dynamic values fall back to node defaults</li>
    </ul>

    <h3>Performance</h3>
    <ul>
        <li><strong>C++ Backend:</strong> Optimized OpenCV algorithms for maximum performance</li>
        <li><strong>Array Support:</strong> Parallel processing of image arrays using Promise.all()</li>
        <li><strong>Memory Efficiency:</strong> In-place processing where possible to minimize memory usage</li>
        <li><strong>Status Display:</strong> Real-time timing information (conversion, processing, encoding)</li>
        <li><strong>Algorithm Optimization:</strong> SIMD instructions and multi-threading where supported</li>
        <li><strong>Performance Metrics:</strong> Processing speed varies by filter: blur/gaussian ~1ms/MP, edge/emboss ~2ms/MP</li>
    </ul>

    <p><strong>Note:</strong> The node status bar displays detailed timing information: conversion time (input processing) + task time (filtering operation) + encoding time (output formatting). Filter performance varies significantly based on kernel size and image complexity.</p>
</script>