<!-- 1 ▸ Runtime registration ------------------------------------------------>
<script type="text/javascript">
    RED.nodes.registerType('padding', {
      category : 'RP Image',
      color    : '#DDA0DD',
      icon     : 'font-awesome/fa-square-o',
      defaults : {
        name:{value:""},
    
        /* I/O */
        inputPath :{value:"payload"}, inputPathType :{value:"msg"},
        outputPath:{value:"payload"}, outputPathType:{value:"msg"},
        outputFormat:{value:"raw"},
        outputQuality:{value:90},
        // Debug configuration
        debugEnabled:{value:false},
    
        /* margins (pixels) */
        top   :{value:"0"}, topType   :{value:"num"},
        bottom:{value:"0"}, bottomType:{value:"num"},
        left  :{value:"0"}, leftType  :{value:"num"},
        right :{value:"0"}, rightType :{value:"num"},
    
        /* colour */
        padColor:{value:"#000000"}
      },
      inputs:1, outputs:1,
      label:function(){ return this.name || "padding"; },
    
      oneditprepare:function(){
        /* I/O path typed‑inputs */
        $("#node-input-inputPath").typedInput({
          default:'msg', types:['msg','flow','global'],
          typeField:"#node-input-inputPathType"
        });
        $("#node-input-outputPath").typedInput({
          default:'msg', types:['msg','flow','global'],
          typeField:"#node-input-outputPathType"
        });
    
        /* margins typed‑inputs */
        ["top","bottom","left","right"].forEach(id=>{
          $("#node-input-"+id).typedInput({
            default:'num',
            types:['num','msg','flow','global'],
            typeField:"#node-input-"+id+"Type"
          });
        });
        
        function updateQualityVisibility(){
          const format = $("#node-input-outputFormat").val();
          $("#quality-row").toggle(format === "jpg" || format === "webp");
        }
        $("#node-input-outputFormat").on("change", updateQualityVisibility);
        updateQualityVisibility(); // initial state

        // === Debug Display Logic ===
        const debugCheckbox = $('#node-input-debugEnabled');
        
        // Initialize debug state on node open
        if (debugCheckbox.is(':checked')) {
            this.debugDisplay = true;
        }
        
        // Handle debug checkbox changes
        debugCheckbox.on('change', function() {
            const enabled = this.checked;
            // Store debug state for runtime access
            $('#node-input-debugEnabled').data('debug-enabled', enabled);
        });
      }
    });

    // Debug image display renderer - shared across all image processing nodes
    if (!window.debugImageRendererInitialized) {
        window.debugImageRendererInitialized = true;
        
        (function() {
            var isSubscribed = false;
            
            function subscribeToDebugImages() {
                if (isSubscribed || typeof RED === 'undefined' || !RED.comms) return;
                isSubscribed = true;
                
                RED.comms.subscribe('debug-image', function(event, data) {
                    if (!data || !data.id) return;
                    
                    try {
                        renderDebugImage(data);
                    } catch (err) {
                        console.warn('Debug image render error:', err);
                    }
                });
            }
            
            function renderDebugImage(data) {
                const nodeId = data.id;
                const base64Data = data.data;
                const format = data.format || 'unknown';
                const mimeType = data.mimeType || 'jpeg';
                
                if (!base64Data) {
                    removeDebugImage(nodeId);
                    return;
                }
                
                const nodeElement = document.getElementById(nodeId);
                if (!nodeElement) return;
                
                let debugContainer = document.getElementById('debug-img-container-' + nodeId);
                
                if (!debugContainer) {
                    // Create SVG foreignObject to embed HTML content in SVG
                    debugContainer = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                    debugContainer.id = 'debug-img-container-' + nodeId;
                    debugContainer.setAttribute('x', '70');
                    debugContainer.setAttribute('y', '5');
                    debugContainer.setAttribute('width', '120');
                    debugContainer.setAttribute('height', '120');
                    debugContainer.style.overflow = 'visible';
                    
                    // Create simple image directly inside foreignObject
                    const img = document.createElement('img');
                    img.id = 'debug-img-' + nodeId;
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.display = 'block';
                    img.style.cursor = 'pointer';
                    img.style.maxHeight = '100px';
                    img.style.maxWidth = '100px';
                    
                    img.onclick = function() {
                        removeDebugImage(nodeId);
                    };
                    
                    debugContainer.appendChild(img);
                    nodeElement.appendChild(debugContainer);
                }
                
                const img = document.getElementById('debug-img-' + nodeId);
                
                if (img) {
                    img.src = `data:image/${mimeType};base64,${base64Data}`;
                    img.title = 'Debug image (click to hide)';
                }
            }
            
            function removeDebugImage(nodeId) {
                const debugContainer = document.getElementById('debug-img-container-' + nodeId);
                if (debugContainer) {
                    debugContainer.remove();
                }
            }
            
            function initializeWhenReady() {
                if (typeof RED !== 'undefined' && RED.comms) {
                    subscribeToDebugImages();
                    
                    // Clean up orphaned debug images periodically
                    setInterval(function() {
                        const debugContainers = document.querySelectorAll('[id^="debug-img-container-"]');
                        debugContainers.forEach(container => {
                            const nodeId = container.id.replace('debug-img-container-', '');
                            const nodeElement = document.getElementById(nodeId);
                            if (!nodeElement) {
                                container.remove();
                            }
                        });
                    }, 5000);
                } else {
                    setTimeout(initializeWhenReady, 100);
                }
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeWhenReady);
            } else {
                initializeWhenReady();
            }
        })();
    }
    </script>
    
    <!-- 2 ▸ Edit‑dialog template ------------------------------------------------>
    <script type="text/x-red" data-template-name="padding">
    <div class="form-row">
      <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
      <input type="text" id="node-input-name">
    </div>
    
    <hr>
    
    <div class="form-row">
      <label for="node-input-inputPath"><i class="fa fa-sign-in"></i> Input</label>
      <input type="text" id="node-input-inputPath" style="width:70%;">
      <input type="hidden" id="node-input-inputPathType">
    </div>
    <div class="form-row">
      <label for="node-input-outputPath"><i class="fa fa-sign-out"></i> Output</label>
      <input type="text" id="node-input-outputPath" style="width:70%;">
      <input type="hidden" id="node-input-outputPathType">
    </div>
    <div class="form-row">
      <label for="node-input-outputFormat"><i class="fa fa-file-image-o"></i> Output Format</label>
      <select id="node-input-outputFormat" style="width: 200px;">
        <option value="raw">Raw (fastest)</option>
        <option value="jpg">JPEG</option>
        <option value="png">PNG</option>
        <option value="webp">WebP</option>
      </select>
    </div>
    <div class="form-row" id="quality-row">
      <label for="node-input-outputQuality"><i class="fa fa-sliders"></i> Quality</label>
      <input type="number" id="node-input-outputQuality" min="1" max="100" value="90" style="width: 70px;">
      <span style="margin-left: 10px; color: #666;">1-100 (JPG/WebP only)</span>
    </div>
    
    <!-- Debug Configuration -->
    <div class="form-row">
      <label for="node-input-debugEnabled"><i class="fa fa-bug"></i> Debug</label>
      <input type="checkbox" id="node-input-debugEnabled" style="display:inline-block; width:auto; vertical-align:baseline;">
      <label for="node-input-debugEnabled" style="width:auto; margin-left:5px;">Show processed image</label>
    </div>
    
    <hr>
    
    <strong>Margins (pixels)</strong>
    <div class="form-row">
      <label>Top</label>
      <input type="text" id="node-input-top" style="width:65%;">
      <input type="hidden" id="node-input-topType">
    </div>
    <div class="form-row">
      <label>Bottom</label>
      <input type="text" id="node-input-bottom" style="width:65%;">
      <input type="hidden" id="node-input-bottomType">
    </div>
    <div class="form-row">
      <label>Left</label>
      <input type="text" id="node-input-left" style="width:65%;">
      <input type="hidden" id="node-input-leftType">
    </div>
    <div class="form-row">
      <label>Right</label>
      <input type="text" id="node-input-right" style="width:65%;">
      <input type="hidden" id="node-input-rightType">
    </div>
    
    <div class="form-row">
      <label for="node-input-padColor"><i class="fa fa-tint"></i> Colour</label>
      <input type="color" id="node-input-padColor" style="width:80px;">
    </div>
    </script>
    
    <!-- 3 ▸ Help panel --------------------------------------------------------->
    <script type="text/x-red" data-help-name="padding">
    <p>The <strong>padding</strong> node adds solid color borders around images with pixel-perfect precision. It supports independent margin control for each side and works with both single images and arrays, using high-performance C++ backend processing with OpenCV.</p>

    <h3>Details</h3>
    <p>This node extends images by adding colored pixels around their edges, effectively increasing the canvas size. The padding operation preserves the original image content while adding configurable margins on all sides. The node maintains the original image's color space and data type while seamlessly integrating the padding color.</p>

    <h3>Properties</h3>
    <dl class="message-properties">
        <dt>Name <span class="property-type">string</span></dt>
        <dd>Optional display name for the node</dd>
        
        <dt>Input from <span class="property-type">msg | flow | global</span></dt>
        <dd>Source path for image data (default: <code>msg.payload</code>)</dd>
        
        <dt>Output to <span class="property-type">msg | flow | global</span></dt>
        <dd>Destination path for processed image (default: <code>msg.payload</code>)</dd>
        
        <dt>Output Format <span class="property-type">string</span></dt>
        <dd>Image output format: <code>raw</code>, <code>jpg</code>, <code>png</code>, or <code>webp</code></dd>
        
        <dt>Quality <span class="property-type">number</span></dt>
        <dd>Compression quality 1-100 for JPEG and WebP formats</dd>
        
        <dt>Top <span class="property-type">number | msg | flow | global</span></dt>
        <dd>Pixels to add above the image (default: 0)</dd>
        
        <dt>Bottom <span class="property-type">number | msg | flow | global</span></dt>
        <dd>Pixels to add below the image (default: 0)</dd>
        
        <dt>Left <span class="property-type">number | msg | flow | global</span></dt>
        <dd>Pixels to add to the left of the image (default: 0)</dd>
        
        <dt>Right <span class="property-type">number | msg | flow | global</span></dt>
        <dd>Pixels to add to the right of the image (default: 0)</dd>
        
        <dt>Colour <span class="property-type">color</span></dt>
        <dd>Hex color code for padding areas (default: #000000)</dd>
    </dl>

    <h3>Inputs</h3>
    <dl class="message-properties">
        <dt>payload <span class="property-type">object | array</span></dt>
        <dd>Image object(s) in standard format:
            <pre>{
  data: Buffer,        // Raw pixel data or file buffer
  width: number,       // Image width in pixels
  height: number,      // Image height in pixels
  channels: number,    // Channel count (1, 3, 4)
  colorSpace: string,  // "GRAY", "RGB", "RGBA", "BGR", "BGRA"
  dtype: string        // "uint8", "uint16", "float32"
}</pre>
        </dd>
        <dt>margin values <span class="property-type">number</span></dt>
        <dd>When margin parameters use dynamic sources, values are read from specified paths</dd>
    </dl>

    <h3>Outputs</h3>
    <dl class="message-properties">
        <dt>payload <span class="property-type">object | array | Buffer</span></dt>
        <dd>Processed image(s) with padding applied. Format depends on Output Format setting</dd>
        
        <dt>Raw format output</dt>
        <dd>Image object with updated dimensions:
            <pre>{
  data: Buffer,        // Padded image data
  width: number,       // Original width + left + right
  height: number,      // Original height + top + bottom
  channels: number,    // Unchanged from input
  colorSpace: string,  // Unchanged from input
  dtype: string        // Unchanged from input
}</pre>
        </dd>
        
        <dt>Encoded format output</dt>
        <dd>Compressed image buffer (JPEG/PNG/WebP) ready for storage or transmission</dd>
    </dl>

    <h3>Padding Behavior</h3>
    <h4>Dimension Calculation</h4>
    <ul>
        <li><strong>New Width:</strong> original_width + left + right</li>
        <li><strong>New Height:</strong> original_height + top + bottom</li>
        <li><strong>Minimum Values:</strong> All margin values must be ≥ 0</li>
        <li><strong>Zero Padding:</strong> When all margins are 0, returns original image unchanged</li>
    </ul>

    <h4>Color Handling</h4>
    <ul>
        <li><strong>Color Format:</strong> Input as hex color (#RRGGBB)</li>
        <li><strong>Channel Mapping:</strong> Automatically converts to image's color space</li>
        <li><strong>Grayscale Images:</strong> Uses luminance value of selected color</li>
        <li><strong>Alpha Channels:</strong> Padding areas receive full opacity (255)</li>
    </ul>

    <h4>Data Type Preservation</h4>
    <ul>
        <li><strong>uint8:</strong> Color values scaled to 0-255 range</li>
        <li><strong>uint16:</strong> Color values scaled to 0-65535 range</li>
        <li><strong>float32:</strong> Color values normalized to 0.0-1.0 range</li>
    </ul>

    <h3>Examples</h3>
    <h4>Basic Uniform Padding</h4>
    <pre>// Add 10 pixels of black padding on all sides
{
  top: 10, bottom: 10, left: 10, right: 10,
  padColor: "#000000"
}</pre>

    <h4>Asymmetric Padding</h4>
    <pre>// Create letterbox effect with white top/bottom bars
{
  top: 50, bottom: 50, left: 0, right: 0,
  padColor: "#FFFFFF"
}</pre>

    <h4>Dynamic Margins</h4>
    <pre>// Use message properties for responsive padding
msg.topPadding = 20;
msg.sidePadding = 15;
// Configure node: top from msg.topPadding, left/right from msg.sidePadding</pre>

    <h4>Colorful Borders</h4>
    <pre>// Add colored border for visual emphasis
{
  top: 5, bottom: 5, left: 5, right: 5,
  padColor: "#FF0000"  // Red border
}</pre>

    <h3>Node Interactions</h3>
    <h4>Pre-Processing Chain</h4>
    <ul>
        <li><strong>image-in → crop → padding:</strong> Crop then add border</li>
        <li><strong>array-select → padding:</strong> Add padding to selected images</li>
        <li><strong>filter → padding:</strong> Apply effects then add border frame</li>
    </ul>

    <h4>Post-Processing Chain</h4>
    <ul>
        <li><strong>padding → resize:</strong> Add padding then scale to final size</li>
        <li><strong>padding → concat:</strong> Pad images before combining</li>
        <li><strong>padding → array-out:</strong> Apply borders then encode for output</li>
    </ul>

    <h4>Common Workflows</h4>
    <ul>
        <li><strong>Thumbnail Generation:</strong> resize → padding → array-out (consistent dimensions)</li>
        <li><strong>Gallery Layout:</strong> padding → concat → mosaic (spaced grid layout)</li>
        <li><strong>Frame Creation:</strong> padding → filter → padding (nested border effects)</li>
    </ul>

    <h3>Output Formats</h3>
    <dl class="message-properties">
        <dt>raw <span class="property-type">object</span></dt>
        <dd>Fastest option. Returns processed image object for further Node-RED processing</dd>
        
        <dt>jpg <span class="property-type">Buffer</span></dt>
        <dd>JPEG-compressed buffer with configurable quality (1-100). Good for photographs</dd>
        
        <dt>png <span class="property-type">Buffer</span></dt>
        <dd>PNG-compressed buffer with lossless compression. Preserves transparency</dd>
        
        <dt>webp <span class="property-type">Buffer</span></dt>
        <dd>WebP-compressed buffer with configurable quality. Modern format with excellent compression</dd>
    </dl>

    <h3>Error Handling</h3>
    <ul>
        <li><strong>Invalid Input:</strong> Non-image objects trigger warnings and prevent processing</li>
        <li><strong>Negative Margins:</strong> Values < 0 are treated as 0 with warning</li>
        <li><strong>Missing Properties:</strong> Incomplete image objects are rejected with detailed error messages</li>
        <li><strong>Memory Limits:</strong> Very large padding operations may fail with memory errors</li>
        <li><strong>Color Format:</strong> Invalid hex colors default to black (#000000)</li>
        <li><strong>Dynamic Values:</strong> Missing or invalid dynamic values default to 0</li>
    </ul>

    <h3>Performance</h3>
    <ul>
        <li><strong>C++ Backend:</strong> High-performance OpenCV-based processing</li>
        <li><strong>Array Support:</strong> Parallel processing of image arrays using Promise.all()</li>
        <li><strong>Memory Efficiency:</strong> Optimized memory allocation for large images</li>
        <li><strong>Status Display:</strong> Real-time timing information (conversion, processing, encoding)</li>
        <li><strong>Zero-Copy:</strong> Minimal memory copying for efficient processing</li>
        <li><strong>Performance Metrics:</strong> Typical processing: <1ms per megapixel for raw output</li>
    </ul>

    <p><strong>Note:</strong> The node status bar displays detailed timing information: conversion time (input processing) + task time (padding operation) + encoding time (output formatting).</p>
    </script>
    