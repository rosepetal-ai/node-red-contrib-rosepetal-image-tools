<script type="text/javascript">
    RED.nodes.registerType('resize', {
        category: 'RP Image',
        color: '#DDA0DD',
        defaults: {
            name: { value: "" },
            // Propiedades para la ruta de Entrada/Salida
            inputPath: { value: "payload" },
            inputPathType: { value: "msg" },
            outputPath: { value: "payload" },
            outputPathType: { value: "msg" },
            outputFormat:  { value: "raw" },
            outputQuality: { value: 90 }, 
            // Debug configuration
            debugEnabled: { value: false },
            // Propiedades para la configuración del Ancho (Width)
            widthMode: { value: "set" },
            widthValue: { value: "" },
            widthType: { value: "num" }, // Tipo para el TypedInput
            // Propiedades para la configuración del Alto (Height)
            heightMode: { value: "set" },
            heightValue: { value: "" },
            heightType: { value: "num" }  // Tipo para el TypedInput
        },
        inputs: 1,
        outputs: 1,
        icon: "font-awesome/fa-arrows-alt",
        label: function() {
            if (this.name) { return this.name; }
            return `resize`;
        },
        oneditprepare: function() {
            // === Inicialización de los Widgets "TypedInput" ===

            // Para las rutas de Input y Output
            $("#node-input-inputPath").typedInput({
                default: 'msg',
                types: ['msg', 'flow', 'global'],
                typeField: "#node-input-inputPathType"
            });
            $("#node-input-outputPath").typedInput({
                default: 'msg',
                types: ['msg', 'flow', 'global'],
                typeField: "#node-input-outputPathType"
            });

            // Para los valores de Width y Height, ahora con flow y global
            const widthTypedInput = $("#node-input-widthValue").typedInput({
                default: 'num',
                types: ['num', 'msg', 'flow', 'global'], // Añadimos flow y global
                typeField: "#node-input-widthType"
            });
            const heightTypedInput = $("#node-input-heightValue").typedInput({
                default: 'num',
                types: ['num', 'msg', 'flow', 'global'], // Añadimos flow y global
                typeField: "#node-input-heightType"
            });

            // === Lógica de Placeholders "Auto" ===
            
            function updatePlaceholders() {
                const widthVal = widthTypedInput.typedInput('value');
                const heightVal = heightTypedInput.typedInput('value');
                
                // El widget TypedInput crea su propio campo de texto, lo seleccionamos
                const widthInputField = widthTypedInput.parent().find('.red-ui-typedInput-input');
                const heightInputField = heightTypedInput.parent().find('.red-ui-typedInput-input');

                const originalWidthPlaceholder = "e.g., 800";
                const originalHeightPlaceholder = "e.g., 600";

                // Lógica final para los placeholders
                if (widthVal === '' && heightVal === '') {
                    widthInputField.attr('placeholder', originalWidthPlaceholder);
                    heightInputField.attr('placeholder', originalHeightPlaceholder);
                } else if (widthVal !== '' && heightVal === '') {
                    heightInputField.attr('placeholder', 'Auto');
                    widthInputField.attr('placeholder', originalWidthPlaceholder);
                } else if (widthVal === '' && heightVal !== '') {
                    widthInputField.attr('placeholder', 'Auto');
                    heightInputField.attr('placeholder', originalHeightPlaceholder);
                } else {
                    widthInputField.attr('placeholder', originalWidthPlaceholder);
                    heightInputField.attr('placeholder', originalHeightPlaceholder);
                }
            }

            // Escuchamos el evento 'change' del widget, que se dispara cuando el tipo o el valor cambian
            widthTypedInput.on('change', updatePlaceholders);
            heightTypedInput.on('change', updatePlaceholders);

            // Llamada inicial para configurar la UI
            updatePlaceholders();

            // === Output Format Logic ===
            function updateQualityVisibility() {
                const format = $('#node-input-outputFormat').val();
                if (format === 'jpg' || format === 'webp') {
                    $('#quality-row').show();
                } else {
                    $('#quality-row').hide();
                }
            }

            $('#node-input-outputFormat').on('change', updateQualityVisibility);
            updateQualityVisibility(); // Initial call

            // === Debug Display Logic ===
            const debugCheckbox = $('#node-input-debugEnabled');
            
            // Initialize debug state on node open
            if (debugCheckbox.is(':checked')) {
                this.debugDisplay = true;
            }
            
            // Handle debug checkbox changes
            debugCheckbox.on('change', function() {
                const enabled = this.checked;
                // Store debug state for runtime access
                $('#node-input-debugEnabled').data('debug-enabled', enabled);
            });
        }
    });

    // Debug image display renderer - shared across all image processing nodes
    if (!window.debugImageRendererInitialized) {
        window.debugImageRendererInitialized = true;
        
        (function() {
            var isSubscribed = false;
            
            function subscribeToDebugImages() {
                if (isSubscribed || typeof RED === 'undefined' || !RED.comms) return;
                isSubscribed = true;
                
                RED.comms.subscribe('debug-image', function(event, data) {
                    if (!data || !data.id) return;
                    
                    try {
                        renderDebugImage(data);
                    } catch (err) {
                        console.warn('Debug image render error:', err);
                    }
                });
            }
            
            function renderDebugImage(data) {
                const nodeId = data.id;
                const base64Data = data.data;
                const format = data.format || 'unknown';
                const mimeType = data.mimeType || 'jpeg';
                
                if (!base64Data) {
                    removeDebugImage(nodeId);
                    return;
                }
                
                const nodeElement = document.getElementById(nodeId);
                if (!nodeElement) return;
                
                let debugContainer = document.getElementById('debug-img-container-' + nodeId);
                
                if (!debugContainer) {
                    // Create SVG foreignObject to embed HTML content in SVG
                    debugContainer = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                    debugContainer.id = 'debug-img-container-' + nodeId;
                    debugContainer.setAttribute('x', '0');
                    debugContainer.setAttribute('y', '45');
                    debugContainer.setAttribute('width', '200');
                    debugContainer.setAttribute('height', '200');
                    debugContainer.style.overflow = 'visible';
                    
                    // Create simple image directly inside foreignObject
                    const img = document.createElement('img');
                    img.id = 'debug-img-' + nodeId;
                    img.style.width = '100%';
                    img.style.height = 'auto';
                    img.style.display = 'block';
                    img.style.cursor = 'pointer';
                    img.style.maxHeight = '100px';
                    img.style.maxWidth = '100px';
                    
                    img.onclick = function() {
                        removeDebugImage(nodeId);
                    };
                    
                    debugContainer.appendChild(img);
                    nodeElement.appendChild(debugContainer);
                }
                
                const img = document.getElementById('debug-img-' + nodeId);
                
                if (img) {
                    img.src = `data:image/${mimeType};base64,${base64Data}`;
                    img.title = 'Debug image (click to hide)';
                }
            }
            
            function removeDebugImage(nodeId) {
                const debugContainer = document.getElementById('debug-img-container-' + nodeId);
                if (debugContainer) {
                    debugContainer.remove();
                }
            }
            
            function initializeWhenReady() {
                if (typeof RED !== 'undefined' && RED.comms) {
                    subscribeToDebugImages();
                    
                    // Clean up orphaned debug images periodically
                    setInterval(function() {
                        const debugContainers = document.querySelectorAll('[id^="debug-img-container-"]');
                        debugContainers.forEach(container => {
                            const nodeId = container.id.replace('debug-img-container-', '');
                            const nodeElement = document.getElementById(nodeId);
                            if (!nodeElement) {
                                container.remove();
                            }
                        });
                    }, 5000);
                } else {
                    setTimeout(initializeWhenReady, 100);
                }
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeWhenReady);
            } else {
                initializeWhenReady();
            }
        })();
    }
</script>

<script type="text/x-red" data-template-name="resize">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>

    <hr>

    <div class="form-row">
        <label for="node-input-inputPath"><i class="fa fa-sign-in"></i> Input from</label>
        <input type="text" id="node-input-inputPath" style="width: 70%;">
        <input type="hidden" id="node-input-inputPathType">
    </div>
    <div class="form-row">
        <label for="node-input-outputPath"><i class="fa fa-sign-out"></i> Output to</label>
        <input type="text" id="node-input-outputPath" style="width: 70%;">
        <input type="hidden" id="node-input-outputPathType">
        
    </div>
    <div class="form-row">
        <label for="node-input-outputFormat"><i class="fa fa-file-image-o"></i> Output Format</label>
        <select id="node-input-outputFormat" style="width: 200px;">
            <option value="raw">Raw (fastest)</option>
            <option value="jpg">JPEG</option>
            <option value="png">PNG</option>
            <option value="webp">WebP</option>
        </select>
    </div>
    <div class="form-row" id="quality-row">
        <label for="node-input-outputQuality"><i class="fa fa-sliders"></i> Quality</label>
        <input type="number" id="node-input-outputQuality" min="1" max="100" value="90" style="width: 70px;">
        <span style="margin-left: 10px; color: #666;">1-100 (JPG/WebP only)</span>
    </div>
    
    <!-- Debug Configuration -->
    <div class="form-row">
        <label for="node-input-debugEnabled"><i class="fa fa-bug"></i> Debug</label>
        <input type="checkbox" id="node-input-debugEnabled" style="display:inline-block; width:auto; vertical-align:baseline;">
        <label for="node-input-debugEnabled" style="width:auto; margin-left:5px;">Show processed image</label>
    </div>
    
    <hr>

    <div class="form-row">
        <label><i class="fa fa-arrows-h"></i> Width</label>
        <div style="display: flex; align-items: center; width: 70%;">
            <select id="node-input-widthMode" style="width: 120px; margin-right: 5px;">
                <option value="set">Set to</option>
                <option value="multiply">Multiply by</option>
            </select>
            <input type="text" id="node-input-widthValue" style="flex-grow: 1;">
            <input type="hidden" id="node-input-widthType">
        </div>
    </div>
    <div class="form-row">
        <label><i class="fa fa-arrows-v"></i> Height</label>
        <div style="display: flex; align-items: center; width: 70%;">
            <select id="node-input-heightMode" style="width: 120px; margin-right: 5px;">
                <option value="set">Set to</option>
                <option value="multiply">Multiply by</option>
            </select>
            <input type="text" id="node-input-heightValue" style="flex-grow: 1;">
            <input type="hidden" id="node-input-heightType">
        </div>
    </div>
    
    <div class="form-tips">
        <b>Tip:</b> If a dimension value is left empty, it will be set to 'Auto' to maintain the original aspect ratio.
    </div>
</script>

<script type="text/x-red" data-help-name="resize">
  <p>Resizes images to specified dimensions using high-performance C++ processing with OpenCV backend.</p>

  <h3>Details</h3>
  <p>This node provides flexible image resizing capabilities with multiple operation modes and dynamic value sources. It supports both single images and arrays, with automatic aspect ratio preservation when one dimension is omitted. All processing is performed asynchronously using the optimized C++ backend.</p>

  <h3>Properties</h3>
  <dl class="message-properties">
    <dt>Input from <span class="property-type">string</span></dt>
    <dd>The location to read image data from. You can select between <code>msg</code>, <code>flow</code>, or <code>global</code> context. Defaults to <code>msg.payload</code>.</dd>
    <dt>Output to <span class="property-type">string</span></dt>
    <dd>The location where the resized image will be stored. You can select between <code>msg</code>, <code>flow</code>, or <code>global</code> context. Defaults to <code>msg.payload</code>.</dd>
    <dt>Output Format <span class="property-type">string</span></dt>
    <dd>Choose output format: <code>raw</code> (fastest, standard image object), <code>jpg</code>, <code>png</code>, or <code>webp</code> (encoded file buffers).</dd>
    <dt>Quality <span class="property-type">number</span></dt>
    <dd>Compression quality for JPEG and WebP formats (1-100). Only visible when jpg or webp format is selected. Default: 90.</dd>
    <dt>Width Mode <span class="property-type">string</span></dt>
    <dd>Width operation: <code>Set to</code> (fixed pixel value) or <code>Multiply by</code> (scale factor).</dd>
    <dt>Width Value <span class="property-type">number|string</span></dt>
    <dd>Width value from number, msg property, flow, or global context. Leave empty for automatic aspect ratio preservation.</dd>
    <dt>Height Mode <span class="property-type">string</span></dt>
    <dd>Height operation: <code>Set to</code> (fixed pixel value) or <code>Multiply by</code> (scale factor).</dd>
    <dt>Height Value <span class="property-type">number|string</span></dt>
    <dd>Height value from number, msg property, flow, or global context. Leave empty for automatic aspect ratio preservation.</dd>
  </dl>

  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>payload <span class="property-type">object | array</span></dt>
    <dd>Single image object or array of image objects in standard format: <code>{ data: Buffer, width: number, height: number, channels: number, colorSpace: string, dtype: string }</code></dd>
  </dl>

  <h3>Outputs</h3>
  <dl class="message-properties">
    <dt>payload <span class="property-type">object | array | Buffer</span></dt>
    <dd>Resized image(s). Format depends on Output Format setting: raw image object(s) or encoded file buffer(s).</dd>
  </dl>

  <h3>Dimension Configuration</h3>
  <p><strong>Operation Modes:</strong></p>
  <ul>
    <li><strong>Set to:</strong> Resizes the dimension to a fixed pixel value (e.g., 800 pixels)</li>
    <li><strong>Multiply by:</strong> Multiplies the original dimension by a factor (e.g., 0.5 for half size, 2.0 for double size)</li>
  </ul>
  <p><strong>Value Sources:</strong> Values can come from fixed numbers, message properties, flow context, or global context using the TypedInput dropdowns.</p>
  <p><strong>Aspect Ratio:</strong> If either width or height is left empty, it will be calculated automatically to maintain the original aspect ratio.</p>

  <h3>Examples</h3>
  <ul>
    <li><strong>Fixed Size:</strong> Width: Set to 800, Height: Set to 600 → All images resized to 800x600</li>
    <li><strong>Proportional:</strong> Width: Set to 800, Height: (empty) → Width set to 800, height calculated proportionally</li>
    <li><strong>Scale Factor:</strong> Width: Multiply by 0.5, Height: Multiply by 0.5 → Images scaled to half size</li>
    <li><strong>Dynamic Values:</strong> Width: Set to msg.targetWidth → Use width value from message property</li>
  </ul>

  <h3>Node Interactions</h3>
  <p><strong>Input Sources:</strong> Image-in, Array-out, other transform nodes</p>
  <p><strong>Output Destinations:</strong> Other transform nodes, Mix nodes (concat, mosaic), Array-in for collections</p>
  <p><strong>Common Workflows:</strong> Image-in → Resize → other transforms, Array processing → Resize → Array-select</p>

  <h3>Output Formats</h3>
  <ul>
    <li><strong>Raw:</strong> Standard image object (fastest, for further processing)</li>
    <li><strong>JPEG:</strong> Compressed file buffer with quality setting</li>
    <li><strong>PNG:</strong> Lossless compressed file buffer</li>
    <li><strong>WebP:</strong> Modern compressed format with quality setting</li>
  </ul>

  <h3>Error Handling</h3>
  <p>The node validates input data and dimensions, displaying warnings for invalid inputs. Processing errors are logged and the message is not propagated.</p>

  <h3>Performance</h3>
  <p>Uses optimized C++ backend with OpenCV for high-performance processing. Node status displays processing time. Array inputs are processed in parallel for optimal performance.</p>
</script>